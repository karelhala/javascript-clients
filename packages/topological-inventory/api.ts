// tslint:disable
/// <reference path="./custom.d.ts" />
/**
 * Topological Inventory
 * Topological Inventory
 *
 * OpenAPI spec version: 1.0.0
 * Contact: support@redhat.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';

const BASE_PATH = "https://cloud.redhat.com//api/topological-inventory/v1.0".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface RequestArgs
 */
export interface RequestArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration | undefined;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected axios: AxiosInstance = globalAxios) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 *
 * @export
 * @interface AvailabilitiesCollection
 */
export interface AvailabilitiesCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof AvailabilitiesCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof AvailabilitiesCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<Availability>}
     * @memberof AvailabilitiesCollection
     */
    data?: Array<Availability>;
}

/**
 *
 * @export
 * @interface Availability
 */
export interface Availability {
    /**
     *
     * @type {string}
     * @memberof Availability
     */
    action?: string;
    /**
     *
     * @type {string}
     * @memberof Availability
     */
    availability?: string;
    /**
     *
     * @type {Date}
     * @memberof Availability
     */
    createdAt?: Date;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Availability
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof Availability
     */
    identifier?: string;
    /**
     *
     * @type {Date}
     * @memberof Availability
     */
    lastCheckedAt?: Date;
    /**
     *
     * @type {Date}
     * @memberof Availability
     */
    lastValidAt?: Date;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Availability
     */
    resourceId?: string;
    /**
     *
     * @type {string}
     * @memberof Availability
     */
    resourceType?: string;
    /**
     *
     * @type {Date}
     * @memberof Availability
     */
    updatedAt?: Date;
}

/**
 *
 * @export
 * @interface CollectionLinks
 */
export interface CollectionLinks {
    /**
     *
     * @type {string}
     * @memberof CollectionLinks
     */
    first?: string;
    /**
     *
     * @type {string}
     * @memberof CollectionLinks
     */
    last?: string;
    /**
     *
     * @type {string}
     * @memberof CollectionLinks
     */
    prev?: string;
    /**
     *
     * @type {string}
     * @memberof CollectionLinks
     */
    next?: string;
}

/**
 *
 * @export
 * @interface CollectionMetadata
 */
export interface CollectionMetadata {
    /**
     *
     * @type {number}
     * @memberof CollectionMetadata
     */
    count?: number;
}

/**
 *
 * @export
 * @interface Container
 */
export interface Container {
    /**
     *
     * @type {Date}
     * @memberof Container
     */
    archivedAt?: Date;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Container
     */
    containerGroupId?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Container
     */
    containerImageId?: string;
    /**
     *
     * @type {number}
     * @memberof Container
     */
    cpuLimit?: number;
    /**
     *
     * @type {number}
     * @memberof Container
     */
    cpuRequest?: number;
    /**
     *
     * @type {Date}
     * @memberof Container
     */
    createdAt?: Date;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Container
     */
    id?: string;
    /**
     *
     * @type {Date}
     * @memberof Container
     */
    lastSeenAt?: Date;
    /**
     *
     * @type {number}
     * @memberof Container
     */
    memoryLimit?: number;
    /**
     *
     * @type {number}
     * @memberof Container
     */
    memoryRequest?: number;
    /**
     *
     * @type {string}
     * @memberof Container
     */
    name?: string;
    /**
     *
     * @type {Date}
     * @memberof Container
     */
    updatedAt?: Date;
}

/**
 *
 * @export
 * @interface ContainerGroup
 */
export interface ContainerGroup {
    /**
     *
     * @type {Date}
     * @memberof ContainerGroup
     */
    archivedAt?: Date;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ContainerGroup
     */
    containerNodeId?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ContainerGroup
     */
    containerProjectId?: string;
    /**
     *
     * @type {Date}
     * @memberof ContainerGroup
     */
    createdAt?: Date;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ContainerGroup
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof ContainerGroup
     */
    ipaddress?: string;
    /**
     *
     * @type {Date}
     * @memberof ContainerGroup
     */
    lastSeenAt?: Date;
    /**
     *
     * @type {string}
     * @memberof ContainerGroup
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof ContainerGroup
     */
    resourceVersion?: string;
    /**
     *
     * @type {Date}
     * @memberof ContainerGroup
     */
    sourceCreatedAt?: Date;
    /**
     *
     * @type {Date}
     * @memberof ContainerGroup
     */
    sourceDeletedAt?: Date;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ContainerGroup
     */
    sourceId?: string;
    /**
     *
     * @type {string}
     * @memberof ContainerGroup
     */
    sourceRef?: string;
    /**
     *
     * @type {Date}
     * @memberof ContainerGroup
     */
    updatedAt?: Date;
}

/**
 *
 * @export
 * @interface ContainerGroupsCollection
 */
export interface ContainerGroupsCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof ContainerGroupsCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof ContainerGroupsCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<ContainerGroup>}
     * @memberof ContainerGroupsCollection
     */
    data?: Array<ContainerGroup>;
}

/**
 *
 * @export
 * @interface ContainerImage
 */
export interface ContainerImage {
    /**
     *
     * @type {Date}
     * @memberof ContainerImage
     */
    archivedAt?: Date;
    /**
     *
     * @type {Date}
     * @memberof ContainerImage
     */
    createdAt?: Date;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ContainerImage
     */
    id?: string;
    /**
     *
     * @type {Date}
     * @memberof ContainerImage
     */
    lastSeenAt?: Date;
    /**
     *
     * @type {string}
     * @memberof ContainerImage
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof ContainerImage
     */
    resourceVersion?: string;
    /**
     *
     * @type {Date}
     * @memberof ContainerImage
     */
    sourceCreatedAt?: Date;
    /**
     *
     * @type {Date}
     * @memberof ContainerImage
     */
    sourceDeletedAt?: Date;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ContainerImage
     */
    sourceId?: string;
    /**
     *
     * @type {string}
     * @memberof ContainerImage
     */
    sourceRef?: string;
    /**
     *
     * @type {string}
     * @memberof ContainerImage
     */
    tag?: string;
    /**
     *
     * @type {Date}
     * @memberof ContainerImage
     */
    updatedAt?: Date;
}

/**
 *
 * @export
 * @interface ContainerImagesCollection
 */
export interface ContainerImagesCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof ContainerImagesCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof ContainerImagesCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<ContainerImage>}
     * @memberof ContainerImagesCollection
     */
    data?: Array<ContainerImage>;
}

/**
 *
 * @export
 * @interface ContainerNode
 */
export interface ContainerNode {
    /**
     *
     * @type {any}
     * @memberof ContainerNode
     */
    addresses?: any;
    /**
     *
     * @type {number}
     * @memberof ContainerNode
     */
    allocatableCpus?: number;
    /**
     *
     * @type {number}
     * @memberof ContainerNode
     */
    allocatableMemory?: number;
    /**
     *
     * @type {number}
     * @memberof ContainerNode
     */
    allocatablePods?: number;
    /**
     *
     * @type {Date}
     * @memberof ContainerNode
     */
    archivedAt?: Date;
    /**
     *
     * @type {any}
     * @memberof ContainerNode
     */
    conditions?: any;
    /**
     *
     * @type {number}
     * @memberof ContainerNode
     */
    cpus?: number;
    /**
     *
     * @type {Date}
     * @memberof ContainerNode
     */
    createdAt?: Date;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ContainerNode
     */
    id?: string;
    /**
     *
     * @type {Date}
     * @memberof ContainerNode
     */
    lastSeenAt?: Date;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ContainerNode
     */
    livesOnId?: string;
    /**
     *
     * @type {string}
     * @memberof ContainerNode
     */
    livesOnType?: string;
    /**
     *
     * @type {number}
     * @memberof ContainerNode
     */
    memory?: number;
    /**
     *
     * @type {string}
     * @memberof ContainerNode
     */
    name?: string;
    /**
     *
     * @type {any}
     * @memberof ContainerNode
     */
    nodeInfo?: any;
    /**
     *
     * @type {number}
     * @memberof ContainerNode
     */
    pods?: number;
    /**
     *
     * @type {string}
     * @memberof ContainerNode
     */
    resourceVersion?: string;
    /**
     *
     * @type {Date}
     * @memberof ContainerNode
     */
    sourceCreatedAt?: Date;
    /**
     *
     * @type {Date}
     * @memberof ContainerNode
     */
    sourceDeletedAt?: Date;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ContainerNode
     */
    sourceId?: string;
    /**
     *
     * @type {string}
     * @memberof ContainerNode
     */
    sourceRef?: string;
    /**
     *
     * @type {Date}
     * @memberof ContainerNode
     */
    updatedAt?: Date;
}

/**
 *
 * @export
 * @interface ContainerNodesCollection
 */
export interface ContainerNodesCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof ContainerNodesCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof ContainerNodesCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<ContainerNode>}
     * @memberof ContainerNodesCollection
     */
    data?: Array<ContainerNode>;
}

/**
 *
 * @export
 * @interface ContainerProject
 */
export interface ContainerProject {
    /**
     *
     * @type {Date}
     * @memberof ContainerProject
     */
    archivedAt?: Date;
    /**
     *
     * @type {Date}
     * @memberof ContainerProject
     */
    createdAt?: Date;
    /**
     *
     * @type {string}
     * @memberof ContainerProject
     */
    displayName?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ContainerProject
     */
    id?: string;
    /**
     *
     * @type {Date}
     * @memberof ContainerProject
     */
    lastSeenAt?: Date;
    /**
     *
     * @type {string}
     * @memberof ContainerProject
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof ContainerProject
     */
    resourceVersion?: string;
    /**
     *
     * @type {Date}
     * @memberof ContainerProject
     */
    sourceCreatedAt?: Date;
    /**
     *
     * @type {Date}
     * @memberof ContainerProject
     */
    sourceDeletedAt?: Date;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ContainerProject
     */
    sourceId?: string;
    /**
     *
     * @type {string}
     * @memberof ContainerProject
     */
    sourceRef?: string;
    /**
     *
     * @type {string}
     * @memberof ContainerProject
     */
    statusPhase?: string;
    /**
     *
     * @type {Date}
     * @memberof ContainerProject
     */
    updatedAt?: Date;
}

/**
 *
 * @export
 * @interface ContainerProjectsCollection
 */
export interface ContainerProjectsCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof ContainerProjectsCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof ContainerProjectsCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<ContainerProject>}
     * @memberof ContainerProjectsCollection
     */
    data?: Array<ContainerProject>;
}

/**
 *
 * @export
 * @interface ContainerResourceQuota
 */
export interface ContainerResourceQuota {
    /**
     *
     * @type {Date}
     * @memberof ContainerResourceQuota
     */
    archivedAt?: Date;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ContainerResourceQuota
     */
    containerProjectId?: string;
    /**
     *
     * @type {Date}
     * @memberof ContainerResourceQuota
     */
    createdAt?: Date;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ContainerResourceQuota
     */
    id?: string;
    /**
     *
     * @type {Date}
     * @memberof ContainerResourceQuota
     */
    lastSeenAt?: Date;
    /**
     *
     * @type {string}
     * @memberof ContainerResourceQuota
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof ContainerResourceQuota
     */
    resourceVersion?: string;
    /**
     *
     * @type {Date}
     * @memberof ContainerResourceQuota
     */
    sourceCreatedAt?: Date;
    /**
     *
     * @type {Date}
     * @memberof ContainerResourceQuota
     */
    sourceDeletedAt?: Date;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ContainerResourceQuota
     */
    sourceId?: string;
    /**
     *
     * @type {string}
     * @memberof ContainerResourceQuota
     */
    sourceRef?: string;
    /**
     *
     * @type {any}
     * @memberof ContainerResourceQuota
     */
    spec?: any;
    /**
     *
     * @type {any}
     * @memberof ContainerResourceQuota
     */
    status?: any;
    /**
     *
     * @type {Date}
     * @memberof ContainerResourceQuota
     */
    updatedAt?: Date;
}

/**
 *
 * @export
 * @interface ContainerResourceQuotaCollection
 */
export interface ContainerResourceQuotaCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof ContainerResourceQuotaCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof ContainerResourceQuotaCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<ContainerResourceQuota>}
     * @memberof ContainerResourceQuotaCollection
     */
    data?: Array<ContainerResourceQuota>;
}

/**
 *
 * @export
 * @interface ContainerTemplate
 */
export interface ContainerTemplate {
    /**
     *
     * @type {Date}
     * @memberof ContainerTemplate
     */
    archivedAt?: Date;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ContainerTemplate
     */
    containerProjectId?: string;
    /**
     *
     * @type {Date}
     * @memberof ContainerTemplate
     */
    createdAt?: Date;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ContainerTemplate
     */
    id?: string;
    /**
     *
     * @type {Date}
     * @memberof ContainerTemplate
     */
    lastSeenAt?: Date;
    /**
     *
     * @type {string}
     * @memberof ContainerTemplate
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof ContainerTemplate
     */
    resourceVersion?: string;
    /**
     *
     * @type {Date}
     * @memberof ContainerTemplate
     */
    sourceCreatedAt?: Date;
    /**
     *
     * @type {Date}
     * @memberof ContainerTemplate
     */
    sourceDeletedAt?: Date;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ContainerTemplate
     */
    sourceId?: string;
    /**
     *
     * @type {string}
     * @memberof ContainerTemplate
     */
    sourceRef?: string;
    /**
     *
     * @type {Date}
     * @memberof ContainerTemplate
     */
    updatedAt?: Date;
}

/**
 *
 * @export
 * @interface ContainerTemplatesCollection
 */
export interface ContainerTemplatesCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof ContainerTemplatesCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof ContainerTemplatesCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<ContainerTemplate>}
     * @memberof ContainerTemplatesCollection
     */
    data?: Array<ContainerTemplate>;
}

/**
 *
 * @export
 * @interface ContainersCollection
 */
export interface ContainersCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof ContainersCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof ContainersCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<Container>}
     * @memberof ContainersCollection
     */
    data?: Array<Container>;
}

/**
 *
 * @export
 * @interface Flavor
 */
export interface Flavor {
    /**
     *
     * @type {Date}
     * @memberof Flavor
     */
    archivedAt?: Date;
    /**
     * Number of CPUs
     * @type {number}
     * @memberof Flavor
     */
    cpus?: number;
    /**
     *
     * @type {Date}
     * @memberof Flavor
     */
    createdAt?: Date;
    /**
     * The number of default disks
     * @type {number}
     * @memberof Flavor
     */
    diskCount?: number;
    /**
     * Size of the default disks in bytes
     * @type {number}
     * @memberof Flavor
     */
    diskSize?: number;
    /**
     *
     * @type {string}
     * @memberof Flavor
     */
    extra?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Flavor
     */
    id?: string;
    /**
     *
     * @type {Date}
     * @memberof Flavor
     */
    lastSeenAt?: Date;
    /**
     * Amount of RAM in bytes
     * @type {number}
     * @memberof Flavor
     */
    memory?: number;
    /**
     *
     * @type {string}
     * @memberof Flavor
     */
    name?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Flavor
     */
    sourceId?: string;
    /**
     *
     * @type {string}
     * @memberof Flavor
     */
    sourceRef?: string;
    /**
     *
     * @type {Date}
     * @memberof Flavor
     */
    updatedAt?: Date;
}

/**
 *
 * @export
 * @interface FlavorsCollection
 */
export interface FlavorsCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof FlavorsCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof FlavorsCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<Flavor>}
     * @memberof FlavorsCollection
     */
    data?: Array<Flavor>;
}

/**
 *
 * @export
 * @interface GraphQLResponse
 */
export interface GraphQLResponse {
    /**
     * Results from the GraphQL query
     * @type {any}
     * @memberof GraphQLResponse
     */
    data?: any;
    /**
     * Errors resulting from the GraphQL query
     * @type {Array<any>}
     * @memberof GraphQLResponse
     */
    errors?: Array<any>;
}

/**
 *
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * The GraphQL query
     * @type {string}
     * @memberof InlineObject
     */
    query: string;
    /**
     * If the Query contains several named operations, the operationName controls which one should be executed
     * @type {string}
     * @memberof InlineObject
     */
    operationName?: string;
    /**
     * Optional Query variables
     * @type {any}
     * @memberof InlineObject
     */
    variables?: any;
}

/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     *
     * @type {string}
     * @memberof InlineResponse200
     */
    taskId?: string;
}

/**
 *
 * @export
 * @interface OrchestrationStack
 */
export interface OrchestrationStack {
    /**
     *
     * @type {Date}
     * @memberof OrchestrationStack
     */
    archivedAt?: Date;
    /**
     *
     * @type {Date}
     * @memberof OrchestrationStack
     */
    createdAt?: Date;
    /**
     * Description of the OrchestrationStack
     * @type {string}
     * @memberof OrchestrationStack
     */
    description?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof OrchestrationStack
     */
    id?: string;
    /**
     *
     * @type {Date}
     * @memberof OrchestrationStack
     */
    lastSeenAt?: Date;
    /**
     *
     * @type {string}
     * @memberof OrchestrationStack
     */
    name?: string;
    /**
     *
     * @type {Date}
     * @memberof OrchestrationStack
     */
    sourceCreatedAt?: Date;
    /**
     *
     * @type {Date}
     * @memberof OrchestrationStack
     */
    sourceDeletedAt?: Date;
    /**
     * ID of the resource
     * @type {string}
     * @memberof OrchestrationStack
     */
    sourceId?: string;
    /**
     *
     * @type {string}
     * @memberof OrchestrationStack
     */
    sourceRef?: string;
    /**
     *
     * @type {Date}
     * @memberof OrchestrationStack
     */
    updatedAt?: Date;
}

/**
 *
 * @export
 * @interface OrchestrationStacksCollection
 */
export interface OrchestrationStacksCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof OrchestrationStacksCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof OrchestrationStacksCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<OrchestrationStack>}
     * @memberof OrchestrationStacksCollection
     */
    data?: Array<OrchestrationStack>;
}

/**
 *
 * @export
 * @interface OrderParameters
 */
export interface OrderParameters {
    /**
     * JSON object with provisioning parameters
     * @type {any}
     * @memberof OrderParameters
     */
    serviceParameters?: any;
    /**
     * The provider specific parameters needed to provision this service. This might include namespaces, special keys
     * @type {any}
     * @memberof OrderParameters
     */
    providerControlParameters?: any;
}

/**
 *
 * @export
 * @interface ServiceInstance
 */
export interface ServiceInstance {
    /**
     *
     * @type {Date}
     * @memberof ServiceInstance
     */
    archivedAt?: Date;
    /**
     *
     * @type {Date}
     * @memberof ServiceInstance
     */
    createdAt?: Date;
    /**
     *
     * @type {string}
     * @memberof ServiceInstance
     */
    externalUrl?: string;
    /**
     * Extra information about this object in JSON format
     * @type {string}
     * @memberof ServiceInstance
     */
    extra?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceInstance
     */
    id?: string;
    /**
     *
     * @type {Date}
     * @memberof ServiceInstance
     */
    lastSeenAt?: Date;
    /**
     *
     * @type {string}
     * @memberof ServiceInstance
     */
    name?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceInstance
     */
    serviceOfferingId?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceInstance
     */
    servicePlanId?: string;
    /**
     *
     * @type {Date}
     * @memberof ServiceInstance
     */
    sourceCreatedAt?: Date;
    /**
     *
     * @type {Date}
     * @memberof ServiceInstance
     */
    sourceDeletedAt?: Date;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceInstance
     */
    sourceId?: string;
    /**
     *
     * @type {string}
     * @memberof ServiceInstance
     */
    sourceRef?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceInstance
     */
    sourceRegionId?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceInstance
     */
    subscriptionId?: string;
    /**
     *
     * @type {Date}
     * @memberof ServiceInstance
     */
    updatedAt?: Date;
}

/**
 *
 * @export
 * @interface ServiceInstancesCollection
 */
export interface ServiceInstancesCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof ServiceInstancesCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof ServiceInstancesCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<ServiceInstance>}
     * @memberof ServiceInstancesCollection
     */
    data?: Array<ServiceInstance>;
}

/**
 *
 * @export
 * @interface ServiceOffering
 */
export interface ServiceOffering {
    /**
     *
     * @type {Date}
     * @memberof ServiceOffering
     */
    archivedAt?: Date;
    /**
     *
     * @type {Date}
     * @memberof ServiceOffering
     */
    createdAt?: Date;
    /**
     *
     * @type {string}
     * @memberof ServiceOffering
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof ServiceOffering
     */
    displayName?: string;
    /**
     *
     * @type {string}
     * @memberof ServiceOffering
     */
    distributor?: string;
    /**
     *
     * @type {string}
     * @memberof ServiceOffering
     */
    documentationUrl?: string;
    /**
     * Extra information about this object in JSON format
     * @type {string}
     * @memberof ServiceOffering
     */
    extra?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceOffering
     */
    id?: string;
    /**
     *
     * @type {Date}
     * @memberof ServiceOffering
     */
    lastSeenAt?: Date;
    /**
     *
     * @type {string}
     * @memberof ServiceOffering
     */
    longDescription?: string;
    /**
     *
     * @type {string}
     * @memberof ServiceOffering
     */
    name?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceOffering
     */
    serviceOfferingIconId?: string;
    /**
     *
     * @type {Date}
     * @memberof ServiceOffering
     */
    sourceCreatedAt?: Date;
    /**
     *
     * @type {Date}
     * @memberof ServiceOffering
     */
    sourceDeletedAt?: Date;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceOffering
     */
    sourceId?: string;
    /**
     * The native reference used by the Source to refer to this object
     * @type {string}
     * @memberof ServiceOffering
     */
    sourceRef?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceOffering
     */
    sourceRegionId?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceOffering
     */
    subscriptionId?: string;
    /**
     *
     * @type {string}
     * @memberof ServiceOffering
     */
    supportUrl?: string;
    /**
     *
     * @type {Date}
     * @memberof ServiceOffering
     */
    updatedAt?: Date;
}

/**
 *
 * @export
 * @interface ServiceOfferingIcon
 */
export interface ServiceOfferingIcon {
    /**
     *
     * @type {Date}
     * @memberof ServiceOfferingIcon
     */
    createdAt?: Date;
    /**
     * Raw icon data
     * @type {string}
     * @memberof ServiceOfferingIcon
     */
    data?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceOfferingIcon
     */
    id?: string;
    /**
     *
     * @type {Date}
     * @memberof ServiceOfferingIcon
     */
    lastSeenAt?: Date;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceOfferingIcon
     */
    sourceId?: string;
    /**
     *
     * @type {string}
     * @memberof ServiceOfferingIcon
     */
    sourceRef?: string;
    /**
     *
     * @type {Date}
     * @memberof ServiceOfferingIcon
     */
    updatedAt?: Date;
}

/**
 *
 * @export
 * @interface ServiceOfferingIconsCollection
 */
export interface ServiceOfferingIconsCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof ServiceOfferingIconsCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof ServiceOfferingIconsCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<ServiceOfferingIcon>}
     * @memberof ServiceOfferingIconsCollection
     */
    data?: Array<ServiceOfferingIcon>;
}

/**
 *
 * @export
 * @interface ServiceOfferingsCollection
 */
export interface ServiceOfferingsCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof ServiceOfferingsCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof ServiceOfferingsCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<ServiceOffering>}
     * @memberof ServiceOfferingsCollection
     */
    data?: Array<ServiceOffering>;
}

/**
 *
 * @export
 * @interface ServicePlan
 */
export interface ServicePlan {
    /**
     *
     * @type {Date}
     * @memberof ServicePlan
     */
    archivedAt?: Date;
    /**
     *
     * @type {any}
     * @memberof ServicePlan
     */
    createJsonSchema?: any;
    /**
     *
     * @type {Date}
     * @memberof ServicePlan
     */
    createdAt?: Date;
    /**
     *
     * @type {string}
     * @memberof ServicePlan
     */
    description?: string;
    /**
     * Extra information about this object in JSON format
     * @type {string}
     * @memberof ServicePlan
     */
    extra?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServicePlan
     */
    id?: string;
    /**
     *
     * @type {Date}
     * @memberof ServicePlan
     */
    lastSeenAt?: Date;
    /**
     *
     * @type {string}
     * @memberof ServicePlan
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof ServicePlan
     */
    resourceVersion?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServicePlan
     */
    serviceOfferingId?: string;
    /**
     *
     * @type {Date}
     * @memberof ServicePlan
     */
    sourceCreatedAt?: Date;
    /**
     *
     * @type {Date}
     * @memberof ServicePlan
     */
    sourceDeletedAt?: Date;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServicePlan
     */
    sourceId?: string;
    /**
     *
     * @type {string}
     * @memberof ServicePlan
     */
    sourceRef?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServicePlan
     */
    sourceRegionId?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServicePlan
     */
    subscriptionId?: string;
    /**
     *
     * @type {string}
     * @memberof ServicePlan
     */
    updateJsonSchema?: string;
    /**
     *
     * @type {Date}
     * @memberof ServicePlan
     */
    updatedAt?: Date;
}

/**
 *
 * @export
 * @interface ServicePlansCollection
 */
export interface ServicePlansCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof ServicePlansCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof ServicePlansCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<ServicePlan>}
     * @memberof ServicePlansCollection
     */
    data?: Array<ServicePlan>;
}

/**
 *
 * @export
 * @interface Source
 */
export interface Source {
    /**
     *
     * @type {Date}
     * @memberof Source
     */
    createdAt?: Date;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Source
     */
    id?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Source
     */
    tenantId?: string;
    /**
     *
     * @type {string}
     * @memberof Source
     */
    uid?: string;
    /**
     *
     * @type {Date}
     * @memberof Source
     */
    updatedAt?: Date;
}

/**
 *
 * @export
 * @interface SourcesCollection
 */
export interface SourcesCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof SourcesCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof SourcesCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<Source>}
     * @memberof SourcesCollection
     */
    data?: Array<Source>;
}

/**
 *
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     *
     * @type {Date}
     * @memberof Tag
     */
    createdAt?: Date;
    /**
     *
     * @type {string}
     * @memberof Tag
     */
    description?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Tag
     */
    id?: string;
    /**
     *
     * @type {Date}
     * @memberof Tag
     */
    lastSeenAt?: Date;
    /**
     *
     * @type {string}
     * @memberof Tag
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof Tag
     */
    namespace?: string;
    /**
     *
     * @type {string}
     * @memberof Tag
     */
    value?: string;
}

/**
 *
 * @export
 * @interface Tagging
 */
export interface Tagging {
    /**
     * ID of the resource
     * @type {string}
     * @memberof Tagging
     */
    tagId?: string;
    /**
     *
     * @type {string}
     * @memberof Tagging
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof Tagging
     */
    value?: string;
}

/**
 *
 * @export
 * @interface TagsCollection
 */
export interface TagsCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof TagsCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof TagsCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<Tag>}
     * @memberof TagsCollection
     */
    data?: Array<Tag>;
}

/**
 *
 * @export
 * @interface Task
 */
export interface Task {
    /**
     *
     * @type {Date}
     * @memberof Task
     */
    completedAt?: Date;
    /**
     *
     * @type {string}
     * @memberof Task
     */
    context?: string;
    /**
     *
     * @type {Date}
     * @memberof Task
     */
    createdAt?: Date;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Task
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof Task
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof Task
     */
    state?: string;
    /**
     *
     * @type {string}
     * @memberof Task
     */
    status?: string;
    /**
     *
     * @type {Date}
     * @memberof Task
     */
    updatedAt?: Date;
}

/**
 *
 * @export
 * @interface TasksCollection
 */
export interface TasksCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof TasksCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof TasksCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<Task>}
     * @memberof TasksCollection
     */
    data?: Array<Task>;
}

/**
 *
 * @export
 * @interface Vm
 */
export interface Vm {
    /**
     *
     * @type {Date}
     * @memberof Vm
     */
    archivedAt?: Date;
    /**
     * Total number of CPUs
     * @type {number}
     * @memberof Vm
     */
    cpus?: number;
    /**
     *
     * @type {Date}
     * @memberof Vm
     */
    createdAt?: Date;
    /**
     * Description of the Vm
     * @type {string}
     * @memberof Vm
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof Vm
     */
    extra?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Vm
     */
    flavorId?: string;
    /**
     *
     * @type {string}
     * @memberof Vm
     */
    hostInventoryUuid?: string;
    /**
     *
     * @type {string}
     * @memberof Vm
     */
    hostname?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Vm
     */
    id?: string;
    /**
     *
     * @type {Date}
     * @memberof Vm
     */
    lastSeenAt?: Date;
    /**
     *
     * @type {Array<string>}
     * @memberof Vm
     */
    macAddresses?: Array<string>;
    /**
     * Total RAM in bytes
     * @type {number}
     * @memberof Vm
     */
    memory?: number;
    /**
     *
     * @type {string}
     * @memberof Vm
     */
    name?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Vm
     */
    orchestrationStackId?: string;
    /**
     *
     * @type {string}
     * @memberof Vm
     */
    powerState?: string;
    /**
     *
     * @type {Date}
     * @memberof Vm
     */
    sourceCreatedAt?: Date;
    /**
     *
     * @type {Date}
     * @memberof Vm
     */
    sourceDeletedAt?: Date;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Vm
     */
    sourceId?: string;
    /**
     *
     * @type {string}
     * @memberof Vm
     */
    sourceRef?: string;
    /**
     * Cross-Source Unique Reference
     * @type {string}
     * @memberof Vm
     */
    uidEms?: string;
    /**
     *
     * @type {Date}
     * @memberof Vm
     */
    updatedAt?: Date;
}

/**
 *
 * @export
 * @interface VmsCollection
 */
export interface VmsCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof VmsCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof VmsCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<Vm>}
     * @memberof VmsCollection
     */
    data?: Array<Vm>;
}

/**
 *
 * @export
 * @interface Volume
 */
export interface Volume {
    /**
     *
     * @type {Date}
     * @memberof Volume
     */
    archivedAt?: Date;
    /**
     *
     * @type {Date}
     * @memberof Volume
     */
    createdAt?: Date;
    /**
     *
     * @type {string}
     * @memberof Volume
     */
    extra?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Volume
     */
    id?: string;
    /**
     *
     * @type {Date}
     * @memberof Volume
     */
    lastSeenAt?: Date;
    /**
     *
     * @type {string}
     * @memberof Volume
     */
    name?: string;
    /**
     * Size of the volume in bytes
     * @type {number}
     * @memberof Volume
     */
    size?: number;
    /**
     *
     * @type {Date}
     * @memberof Volume
     */
    sourceCreatedAt?: Date;
    /**
     *
     * @type {Date}
     * @memberof Volume
     */
    sourceDeletedAt?: Date;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Volume
     */
    sourceId?: string;
    /**
     *
     * @type {string}
     * @memberof Volume
     */
    sourceRef?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Volume
     */
    sourceRegionId?: string;
    /**
     *
     * @type {string}
     * @memberof Volume
     */
    state?: string;
    /**
     *
     * @type {Date}
     * @memberof Volume
     */
    updatedAt?: Date;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Volume
     */
    volumeTypeId?: string;
}

/**
 *
 * @export
 * @interface VolumeAttachment
 */
export interface VolumeAttachment {
    /**
     *
     * @type {string}
     * @memberof VolumeAttachment
     */
    device?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof VolumeAttachment
     */
    id?: string;
    /**
     *
     * @type {Date}
     * @memberof VolumeAttachment
     */
    lastSeenAt?: Date;
    /**
     *
     * @type {string}
     * @memberof VolumeAttachment
     */
    state?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof VolumeAttachment
     */
    vmId?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof VolumeAttachment
     */
    volumeId?: string;
}

/**
 *
 * @export
 * @interface VolumeAttachmentsCollection
 */
export interface VolumeAttachmentsCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof VolumeAttachmentsCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof VolumeAttachmentsCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<VolumeAttachment>}
     * @memberof VolumeAttachmentsCollection
     */
    data?: Array<VolumeAttachment>;
}

/**
 *
 * @export
 * @interface VolumeType
 */
export interface VolumeType {
    /**
     *
     * @type {Date}
     * @memberof VolumeType
     */
    archivedAt?: Date;
    /**
     *
     * @type {Date}
     * @memberof VolumeType
     */
    createdAt?: Date;
    /**
     *
     * @type {string}
     * @memberof VolumeType
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof VolumeType
     */
    extra?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof VolumeType
     */
    id?: string;
    /**
     *
     * @type {Date}
     * @memberof VolumeType
     */
    lastSeenAt?: Date;
    /**
     *
     * @type {string}
     * @memberof VolumeType
     */
    name?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof VolumeType
     */
    sourceId?: string;
    /**
     *
     * @type {string}
     * @memberof VolumeType
     */
    sourceRef?: string;
    /**
     *
     * @type {Date}
     * @memberof VolumeType
     */
    updatedAt?: Date;
}

/**
 *
 * @export
 * @interface VolumeTypesCollection
 */
export interface VolumeTypesCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof VolumeTypesCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof VolumeTypesCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<VolumeType>}
     * @memberof VolumeTypesCollection
     */
    data?: Array<VolumeType>;
}

/**
 *
 * @export
 * @interface VolumesCollection
 */
export interface VolumesCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof VolumesCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof VolumesCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<Volume>}
     * @memberof VolumesCollection
     */
    data?: Array<Volume>;
}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Return this API document in JSON format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentation(options: any = {}): RequestArgs {
            const localVarPath = `/openapi.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Container objects
         * @summary List Containers for ContainerGroup
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerGroupContainers(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listContainerGroupContainers.');
            }
            const localVarPath = `/container_groups/{id}/containers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Tag objects
         * @summary List Tags for ContainerGroup
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerGroupTags(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listContainerGroupTags.');
            }
            const localVarPath = `/container_groups/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerGroup objects
         * @summary List ContainerGroups
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerGroups(limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            const localVarPath = `/container_groups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Tag objects
         * @summary List Tags for ContainerImage
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerImageTags(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listContainerImageTags.');
            }
            const localVarPath = `/container_images/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerImage objects
         * @summary List ContainerImages
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerImages(limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            const localVarPath = `/container_images`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerGroup objects
         * @summary List ContainerGroups for ContainerNode
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerNodeContainerGroups(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listContainerNodeContainerGroups.');
            }
            const localVarPath = `/container_nodes/{id}/container_groups`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Tag objects
         * @summary List Tags for ContainerNode
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerNodeTags(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listContainerNodeTags.');
            }
            const localVarPath = `/container_nodes/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerNode objects
         * @summary List ContainerNodes
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerNodes(limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            const localVarPath = `/container_nodes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerGroup objects
         * @summary List ContainerGroups for ContainerProject
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerProjectContainerGroups(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listContainerProjectContainerGroups.');
            }
            const localVarPath = `/container_projects/{id}/container_groups`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerResourceQuota objects
         * @summary List ContainerResourceQuota for ContainerProject
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerProjectContainerResourceQuota(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listContainerProjectContainerResourceQuota.');
            }
            const localVarPath = `/container_projects/{id}/container_resource_quotas`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerTemplate objects
         * @summary List ContainerTemplates for ContainerProject
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerProjectContainerTemplates(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listContainerProjectContainerTemplates.');
            }
            const localVarPath = `/container_projects/{id}/container_templates`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Tag objects
         * @summary List Tags for ContainerProject
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerProjectTags(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listContainerProjectTags.');
            }
            const localVarPath = `/container_projects/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerProject objects
         * @summary List ContainerProjects
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerProjects(limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            const localVarPath = `/container_projects`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerResourceQuota objects
         * @summary List ContainerResourceQuota
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerResourceQuota(limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            const localVarPath = `/container_resource_quotas`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Tag objects
         * @summary List Tags for ContainerTemplate
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerTemplateTags(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listContainerTemplateTags.');
            }
            const localVarPath = `/container_templates/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerTemplate objects
         * @summary List ContainerTemplates
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerTemplates(limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            const localVarPath = `/container_templates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Container objects
         * @summary List Containers
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainers(limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            const localVarPath = `/containers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Flavor objects
         * @summary List Flavors
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFlavors(limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            const localVarPath = `/flavors`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of OrchestrationStack objects
         * @summary List OrchestrationStacks
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrchestrationStacks(limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            const localVarPath = `/orchestration_stacks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ServiceInstance objects
         * @summary List ServiceInstances
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceInstances(limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            const localVarPath = `/service_instances`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ServiceOfferingIcon objects
         * @summary List ServiceOfferingIcons
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceOfferingIcons(limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            const localVarPath = `/service_offering_icons`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ServiceInstance objects
         * @summary List ServiceInstances for ServiceOffering
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceOfferingServiceInstances(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listServiceOfferingServiceInstances.');
            }
            const localVarPath = `/service_offerings/{id}/service_instances`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ServicePlan objects
         * @summary List ServicePlans for ServiceOffering
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceOfferingServicePlans(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listServiceOfferingServicePlans.');
            }
            const localVarPath = `/service_offerings/{id}/service_plans`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Tag objects
         * @summary List Tags for ServiceOffering
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceOfferingTags(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listServiceOfferingTags.');
            }
            const localVarPath = `/service_offerings/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ServiceOffering objects
         * @summary List ServiceOfferings
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceOfferings(limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            const localVarPath = `/service_offerings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ServiceInstance objects
         * @summary List ServiceInstances for ServicePlan
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServicePlanServiceInstances(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listServicePlanServiceInstances.');
            }
            const localVarPath = `/service_plans/{id}/service_instances`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ServicePlan objects
         * @summary List ServicePlans
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServicePlans(limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            const localVarPath = `/service_plans`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Availability objects
         * @summary List Availabilities for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceAvailabilities(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceAvailabilities.');
            }
            const localVarPath = `/sources/{id}/availabilities`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerGroup objects
         * @summary List ContainerGroups for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceContainerGroups(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceContainerGroups.');
            }
            const localVarPath = `/sources/{id}/container_groups`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerImage objects
         * @summary List ContainerImages for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceContainerImages(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceContainerImages.');
            }
            const localVarPath = `/sources/{id}/container_images`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerNode objects
         * @summary List ContainerNodes for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceContainerNodes(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceContainerNodes.');
            }
            const localVarPath = `/sources/{id}/container_nodes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerProject objects
         * @summary List ContainerProjects for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceContainerProjects(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceContainerProjects.');
            }
            const localVarPath = `/sources/{id}/container_projects`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerTemplate objects
         * @summary List ContainerTemplates for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceContainerTemplates(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceContainerTemplates.');
            }
            const localVarPath = `/sources/{id}/container_templates`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Container objects
         * @summary List Containers for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceContainers(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceContainers.');
            }
            const localVarPath = `/sources/{id}/containers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of OrchestrationStack objects
         * @summary List OrchestrationStacks for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceOrchestrationStacks(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceOrchestrationStacks.');
            }
            const localVarPath = `/sources/{id}/orchestration_stacks`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ServiceInstance objects
         * @summary List ServiceInstances for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceServiceInstances(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceServiceInstances.');
            }
            const localVarPath = `/sources/{id}/service_instances`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ServiceOffering objects
         * @summary List ServiceOfferings for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceServiceOfferings(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceServiceOfferings.');
            }
            const localVarPath = `/sources/{id}/service_offerings`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ServicePlan objects
         * @summary List ServicePlans for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceServicePlans(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceServicePlans.');
            }
            const localVarPath = `/sources/{id}/service_plans`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Vm objects
         * @summary List Vms for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceVms(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceVms.');
            }
            const localVarPath = `/sources/{id}/vms`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of VolumeType objects
         * @summary List VolumeTypes for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceVolumeTypes(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceVolumeTypes.');
            }
            const localVarPath = `/sources/{id}/volume_types`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Volume objects
         * @summary List Volumes for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceVolumes(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceVolumes.');
            }
            const localVarPath = `/sources/{id}/volumes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Source objects
         * @summary List Sources
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSources(limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            const localVarPath = `/sources`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerGroup objects
         * @summary List ContainerGroups for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagContainerGroups(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listTagContainerGroups.');
            }
            const localVarPath = `/tags/{id}/container_groups`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerImage objects
         * @summary List ContainerImages for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagContainerImages(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listTagContainerImages.');
            }
            const localVarPath = `/tags/{id}/container_images`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerNode objects
         * @summary List ContainerNodes for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagContainerNodes(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listTagContainerNodes.');
            }
            const localVarPath = `/tags/{id}/container_nodes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerProject objects
         * @summary List ContainerProjects for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagContainerProjects(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listTagContainerProjects.');
            }
            const localVarPath = `/tags/{id}/container_projects`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerTemplate objects
         * @summary List ContainerTemplates for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagContainerTemplates(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listTagContainerTemplates.');
            }
            const localVarPath = `/tags/{id}/container_templates`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ServiceOffering objects
         * @summary List ServiceOfferings for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagServiceOfferings(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listTagServiceOfferings.');
            }
            const localVarPath = `/tags/{id}/service_offerings`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Vm objects
         * @summary List Vms for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagVms(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listTagVms.');
            }
            const localVarPath = `/tags/{id}/vms`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Tag objects
         * @summary List Tags
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTags(limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            const localVarPath = `/tags`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Task objects
         * @summary List Tasks
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTasks(limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            const localVarPath = `/tasks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Tag objects
         * @summary List Tags for Vm
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVmTags(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listVmTags.');
            }
            const localVarPath = `/vms/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of VolumeAttachment objects
         * @summary List VolumeAttachments for Vm
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVmVolumeAttachments(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listVmVolumeAttachments.');
            }
            const localVarPath = `/vms/{id}/volume_attachments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Volume objects
         * @summary List Volumes for Vm
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVmVolumes(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listVmVolumes.');
            }
            const localVarPath = `/vms/{id}/volumes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Vm objects
         * @summary List Vms
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVms(limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            const localVarPath = `/vms`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of VolumeAttachment objects
         * @summary List VolumeAttachments
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolumeAttachments(limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            const localVarPath = `/volume_attachments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of VolumeType objects
         * @summary List VolumeTypes
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolumeTypes(limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            const localVarPath = `/volume_types`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Volume objects
         * @summary List Volumes
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolumes(limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            const localVarPath = `/volumes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Task id
         * @summary Order an existing ServicePlan
         * @param {string} id ID of the resource
         * @param {OrderParameters} orderParameters Order parameters defining the service and provider control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderServicePlan(id: string, orderParameters: OrderParameters, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling orderServicePlan.');
            }
            // verify required parameter 'orderParameters' is not null or undefined
            if (orderParameters === null || orderParameters === undefined) {
                throw new RequiredError('orderParameters','Required parameter orderParameters was null or undefined when calling orderServicePlan.');
            }
            const localVarPath = `/service_plans/{id}/order`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OrderParameters" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(orderParameters || {}) : (orderParameters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs a GraphQL Query
         * @summary Perform a GraphQL Query
         * @param {InlineObject} inlineObject
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGraphQL(inlineObject: InlineObject, options: any = {}): RequestArgs {
            // verify required parameter 'inlineObject' is not null or undefined
            if (inlineObject === null || inlineObject === undefined) {
                throw new RequiredError('inlineObject','Required parameter inlineObject was null or undefined when calling postGraphQL.');
            }
            const localVarPath = `/graphql`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"InlineObject" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject || {}) : (inlineObject || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Container object
         * @summary Show an existing Container
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showContainer(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showContainer.');
            }
            const localVarPath = `/containers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a ContainerGroup object
         * @summary Show an existing ContainerGroup
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showContainerGroup(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showContainerGroup.');
            }
            const localVarPath = `/container_groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a ContainerImage object
         * @summary Show an existing ContainerImage
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showContainerImage(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showContainerImage.');
            }
            const localVarPath = `/container_images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a ContainerNode object
         * @summary Show an existing ContainerNode
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showContainerNode(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showContainerNode.');
            }
            const localVarPath = `/container_nodes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a ContainerProject object
         * @summary Show an existing ContainerProject
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showContainerProject(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showContainerProject.');
            }
            const localVarPath = `/container_projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a ContainerResourceQuota object
         * @summary Show an existing ContainerResourceQuota
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showContainerResourceQuota(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showContainerResourceQuota.');
            }
            const localVarPath = `/container_resource_quotas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a ContainerTemplate object
         * @summary Show an existing ContainerTemplate
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showContainerTemplate(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showContainerTemplate.');
            }
            const localVarPath = `/container_templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Flavor object
         * @summary Show an existing Flavor
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showFlavor(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showFlavor.');
            }
            const localVarPath = `/flavors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a OrchestrationStack object
         * @summary Show an existing OrchestrationStack
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showOrchestrationStack(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showOrchestrationStack.');
            }
            const localVarPath = `/orchestration_stacks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a ServiceInstance object
         * @summary Show an existing ServiceInstance
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServiceInstance(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showServiceInstance.');
            }
            const localVarPath = `/service_instances/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a ServiceOffering object
         * @summary Show an existing ServiceOffering
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServiceOffering(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showServiceOffering.');
            }
            const localVarPath = `/service_offerings/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a ServiceOfferingIcon object
         * @summary Show an existing ServiceOfferingIcon
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServiceOfferingIcon(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showServiceOfferingIcon.');
            }
            const localVarPath = `/service_offering_icons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a ServiceOfferingIcon IconData
         * @summary Show an existing ServiceOfferingIcon IconData
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServiceOfferingIconIconData(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showServiceOfferingIconIconData.');
            }
            const localVarPath = `/service_offering_icons/{id}/icon_data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a ServicePlan object
         * @summary Show an existing ServicePlan
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServicePlan(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showServicePlan.');
            }
            const localVarPath = `/service_plans/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Source object
         * @summary Show an existing Source
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showSource(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showSource.');
            }
            const localVarPath = `/sources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Tag object
         * @summary Show an existing Tag
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showTag(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showTag.');
            }
            const localVarPath = `/tags/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Task object
         * @summary Show an existing Task
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showTask(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showTask.');
            }
            const localVarPath = `/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Vm object
         * @summary Show an existing Vm
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showVm(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showVm.');
            }
            const localVarPath = `/vms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Volume object
         * @summary Show an existing Volume
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showVolume(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showVolume.');
            }
            const localVarPath = `/volumes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a VolumeAttachment object
         * @summary Show an existing VolumeAttachment
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showVolumeAttachment(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showVolumeAttachment.');
            }
            const localVarPath = `/volume_attachments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a VolumeType object
         * @summary Show an existing VolumeType
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showVolumeType(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showVolumeType.');
            }
            const localVarPath = `/volume_types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Task object
         * @summary Update an existing Task
         * @param {string} id ID of the resource
         * @param {Task} task Task attributes to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTask(id: string, task: Task, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateTask.');
            }
            // verify required parameter 'task' is not null or undefined
            if (task === null || task === undefined) {
                throw new RequiredError('task','Required parameter task was null or undefined when calling updateTask.');
            }
            const localVarPath = `/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Task" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(task || {}) : (task || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Return this API document in JSON format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentation(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).getDocumentation(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Container objects
         * @summary List Containers for ContainerGroup
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerGroupContainers(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainersCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listContainerGroupContainers(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Tag objects
         * @summary List Tags for ContainerGroup
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerGroupTags(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listContainerGroupTags(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerGroup objects
         * @summary List ContainerGroups
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerGroups(limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerGroupsCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listContainerGroups(limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Tag objects
         * @summary List Tags for ContainerImage
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerImageTags(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listContainerImageTags(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerImage objects
         * @summary List ContainerImages
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerImages(limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerImagesCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listContainerImages(limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerGroup objects
         * @summary List ContainerGroups for ContainerNode
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerNodeContainerGroups(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerGroupsCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listContainerNodeContainerGroups(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Tag objects
         * @summary List Tags for ContainerNode
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerNodeTags(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listContainerNodeTags(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerNode objects
         * @summary List ContainerNodes
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerNodes(limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerNodesCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listContainerNodes(limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerGroup objects
         * @summary List ContainerGroups for ContainerProject
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerProjectContainerGroups(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerGroupsCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listContainerProjectContainerGroups(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerResourceQuota objects
         * @summary List ContainerResourceQuota for ContainerProject
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerProjectContainerResourceQuota(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerResourceQuotaCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listContainerProjectContainerResourceQuota(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerTemplate objects
         * @summary List ContainerTemplates for ContainerProject
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerProjectContainerTemplates(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerTemplatesCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listContainerProjectContainerTemplates(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Tag objects
         * @summary List Tags for ContainerProject
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerProjectTags(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listContainerProjectTags(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerProject objects
         * @summary List ContainerProjects
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerProjects(limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerProjectsCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listContainerProjects(limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerResourceQuota objects
         * @summary List ContainerResourceQuota
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerResourceQuota(limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerResourceQuotaCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listContainerResourceQuota(limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Tag objects
         * @summary List Tags for ContainerTemplate
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerTemplateTags(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listContainerTemplateTags(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerTemplate objects
         * @summary List ContainerTemplates
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerTemplates(limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerTemplatesCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listContainerTemplates(limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Container objects
         * @summary List Containers
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainers(limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainersCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listContainers(limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Flavor objects
         * @summary List Flavors
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFlavors(limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlavorsCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listFlavors(limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of OrchestrationStack objects
         * @summary List OrchestrationStacks
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrchestrationStacks(limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrchestrationStacksCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listOrchestrationStacks(limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ServiceInstance objects
         * @summary List ServiceInstances
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceInstances(limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceInstancesCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listServiceInstances(limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ServiceOfferingIcon objects
         * @summary List ServiceOfferingIcons
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceOfferingIcons(limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceOfferingIconsCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listServiceOfferingIcons(limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ServiceInstance objects
         * @summary List ServiceInstances for ServiceOffering
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceOfferingServiceInstances(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceInstancesCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listServiceOfferingServiceInstances(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ServicePlan objects
         * @summary List ServicePlans for ServiceOffering
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceOfferingServicePlans(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServicePlansCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listServiceOfferingServicePlans(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Tag objects
         * @summary List Tags for ServiceOffering
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceOfferingTags(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listServiceOfferingTags(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ServiceOffering objects
         * @summary List ServiceOfferings
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceOfferings(limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceOfferingsCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listServiceOfferings(limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ServiceInstance objects
         * @summary List ServiceInstances for ServicePlan
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServicePlanServiceInstances(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceInstancesCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listServicePlanServiceInstances(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ServicePlan objects
         * @summary List ServicePlans
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServicePlans(limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServicePlansCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listServicePlans(limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Availability objects
         * @summary List Availabilities for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceAvailabilities(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailabilitiesCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listSourceAvailabilities(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerGroup objects
         * @summary List ContainerGroups for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceContainerGroups(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerGroupsCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listSourceContainerGroups(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerImage objects
         * @summary List ContainerImages for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceContainerImages(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerImagesCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listSourceContainerImages(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerNode objects
         * @summary List ContainerNodes for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceContainerNodes(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerNodesCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listSourceContainerNodes(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerProject objects
         * @summary List ContainerProjects for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceContainerProjects(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerProjectsCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listSourceContainerProjects(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerTemplate objects
         * @summary List ContainerTemplates for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceContainerTemplates(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerTemplatesCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listSourceContainerTemplates(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Container objects
         * @summary List Containers for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceContainers(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainersCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listSourceContainers(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of OrchestrationStack objects
         * @summary List OrchestrationStacks for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceOrchestrationStacks(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrchestrationStacksCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listSourceOrchestrationStacks(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ServiceInstance objects
         * @summary List ServiceInstances for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceServiceInstances(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceInstancesCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listSourceServiceInstances(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ServiceOffering objects
         * @summary List ServiceOfferings for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceServiceOfferings(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceOfferingsCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listSourceServiceOfferings(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ServicePlan objects
         * @summary List ServicePlans for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceServicePlans(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServicePlansCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listSourceServicePlans(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Vm objects
         * @summary List Vms for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceVms(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<VmsCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listSourceVms(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of VolumeType objects
         * @summary List VolumeTypes for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceVolumeTypes(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolumeTypesCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listSourceVolumeTypes(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Volume objects
         * @summary List Volumes for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceVolumes(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolumesCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listSourceVolumes(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Source objects
         * @summary List Sources
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSources(limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourcesCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listSources(limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerGroup objects
         * @summary List ContainerGroups for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagContainerGroups(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerGroupsCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listTagContainerGroups(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerImage objects
         * @summary List ContainerImages for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagContainerImages(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerImagesCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listTagContainerImages(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerNode objects
         * @summary List ContainerNodes for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagContainerNodes(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerNodesCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listTagContainerNodes(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerProject objects
         * @summary List ContainerProjects for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagContainerProjects(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerProjectsCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listTagContainerProjects(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerTemplate objects
         * @summary List ContainerTemplates for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagContainerTemplates(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerTemplatesCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listTagContainerTemplates(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ServiceOffering objects
         * @summary List ServiceOfferings for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagServiceOfferings(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceOfferingsCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listTagServiceOfferings(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Vm objects
         * @summary List Vms for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagVms(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<VmsCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listTagVms(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Tag objects
         * @summary List Tags
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTags(limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listTags(limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Task objects
         * @summary List Tasks
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTasks(limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TasksCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listTasks(limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Tag objects
         * @summary List Tags for Vm
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVmTags(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listVmTags(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of VolumeAttachment objects
         * @summary List VolumeAttachments for Vm
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVmVolumeAttachments(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolumeAttachmentsCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listVmVolumeAttachments(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Volume objects
         * @summary List Volumes for Vm
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVmVolumes(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolumesCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listVmVolumes(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Vm objects
         * @summary List Vms
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVms(limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<VmsCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listVms(limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of VolumeAttachment objects
         * @summary List VolumeAttachments
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolumeAttachments(limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolumeAttachmentsCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listVolumeAttachments(limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of VolumeType objects
         * @summary List VolumeTypes
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolumeTypes(limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolumeTypesCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listVolumeTypes(limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Volume objects
         * @summary List Volumes
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolumes(limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolumesCollection> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).listVolumes(limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a Task id
         * @summary Order an existing ServicePlan
         * @param {string} id ID of the resource
         * @param {OrderParameters} orderParameters Order parameters defining the service and provider control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderServicePlan(id: string, orderParameters: OrderParameters, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).orderServicePlan(id, orderParameters, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Performs a GraphQL Query
         * @summary Perform a GraphQL Query
         * @param {InlineObject} inlineObject
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGraphQL(inlineObject: InlineObject, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphQLResponse> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).postGraphQL(inlineObject, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a Container object
         * @summary Show an existing Container
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showContainer(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Container> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).showContainer(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a ContainerGroup object
         * @summary Show an existing ContainerGroup
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showContainerGroup(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerGroup> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).showContainerGroup(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a ContainerImage object
         * @summary Show an existing ContainerImage
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showContainerImage(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerImage> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).showContainerImage(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a ContainerNode object
         * @summary Show an existing ContainerNode
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showContainerNode(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerNode> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).showContainerNode(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a ContainerProject object
         * @summary Show an existing ContainerProject
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showContainerProject(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerProject> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).showContainerProject(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a ContainerResourceQuota object
         * @summary Show an existing ContainerResourceQuota
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showContainerResourceQuota(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerResourceQuota> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).showContainerResourceQuota(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a ContainerTemplate object
         * @summary Show an existing ContainerTemplate
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showContainerTemplate(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerTemplate> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).showContainerTemplate(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a Flavor object
         * @summary Show an existing Flavor
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showFlavor(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Flavor> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).showFlavor(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a OrchestrationStack object
         * @summary Show an existing OrchestrationStack
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showOrchestrationStack(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrchestrationStack> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).showOrchestrationStack(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a ServiceInstance object
         * @summary Show an existing ServiceInstance
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServiceInstance(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceInstance> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).showServiceInstance(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a ServiceOffering object
         * @summary Show an existing ServiceOffering
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServiceOffering(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceOffering> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).showServiceOffering(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a ServiceOfferingIcon object
         * @summary Show an existing ServiceOfferingIcon
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServiceOfferingIcon(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceOfferingIcon> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).showServiceOfferingIcon(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a ServiceOfferingIcon IconData
         * @summary Show an existing ServiceOfferingIcon IconData
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServiceOfferingIconIconData(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).showServiceOfferingIconIconData(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a ServicePlan object
         * @summary Show an existing ServicePlan
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServicePlan(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServicePlan> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).showServicePlan(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a Source object
         * @summary Show an existing Source
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showSource(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).showSource(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a Tag object
         * @summary Show an existing Tag
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showTag(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).showTag(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a Task object
         * @summary Show an existing Task
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showTask(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).showTask(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a Vm object
         * @summary Show an existing Vm
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showVm(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vm> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).showVm(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a Volume object
         * @summary Show an existing Volume
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showVolume(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Volume> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).showVolume(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a VolumeAttachment object
         * @summary Show an existing VolumeAttachment
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showVolumeAttachment(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolumeAttachment> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).showVolumeAttachment(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a VolumeType object
         * @summary Show an existing VolumeType
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showVolumeType(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolumeType> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).showVolumeType(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates a Task object
         * @summary Update an existing Task
         * @param {string} id ID of the resource
         * @param {Task} task Task attributes to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTask(id: string, task: Task, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).updateTask(id, task, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @summary Return this API document in JSON format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentation(options?: any) {
            return DefaultApiFp(configuration).getDocumentation(options)(axios, basePath);
        },
        /**
         * Returns an array of Container objects
         * @summary List Containers for ContainerGroup
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerGroupContainers(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listContainerGroupContainers(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of Tag objects
         * @summary List Tags for ContainerGroup
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerGroupTags(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listContainerGroupTags(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of ContainerGroup objects
         * @summary List ContainerGroups
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerGroups(limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listContainerGroups(limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of Tag objects
         * @summary List Tags for ContainerImage
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerImageTags(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listContainerImageTags(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of ContainerImage objects
         * @summary List ContainerImages
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerImages(limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listContainerImages(limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of ContainerGroup objects
         * @summary List ContainerGroups for ContainerNode
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerNodeContainerGroups(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listContainerNodeContainerGroups(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of Tag objects
         * @summary List Tags for ContainerNode
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerNodeTags(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listContainerNodeTags(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of ContainerNode objects
         * @summary List ContainerNodes
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerNodes(limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listContainerNodes(limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of ContainerGroup objects
         * @summary List ContainerGroups for ContainerProject
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerProjectContainerGroups(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listContainerProjectContainerGroups(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of ContainerResourceQuota objects
         * @summary List ContainerResourceQuota for ContainerProject
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerProjectContainerResourceQuota(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listContainerProjectContainerResourceQuota(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of ContainerTemplate objects
         * @summary List ContainerTemplates for ContainerProject
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerProjectContainerTemplates(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listContainerProjectContainerTemplates(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of Tag objects
         * @summary List Tags for ContainerProject
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerProjectTags(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listContainerProjectTags(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of ContainerProject objects
         * @summary List ContainerProjects
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerProjects(limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listContainerProjects(limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of ContainerResourceQuota objects
         * @summary List ContainerResourceQuota
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerResourceQuota(limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listContainerResourceQuota(limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of Tag objects
         * @summary List Tags for ContainerTemplate
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerTemplateTags(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listContainerTemplateTags(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of ContainerTemplate objects
         * @summary List ContainerTemplates
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerTemplates(limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listContainerTemplates(limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of Container objects
         * @summary List Containers
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainers(limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listContainers(limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of Flavor objects
         * @summary List Flavors
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFlavors(limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listFlavors(limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of OrchestrationStack objects
         * @summary List OrchestrationStacks
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrchestrationStacks(limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listOrchestrationStacks(limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of ServiceInstance objects
         * @summary List ServiceInstances
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceInstances(limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listServiceInstances(limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of ServiceOfferingIcon objects
         * @summary List ServiceOfferingIcons
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceOfferingIcons(limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listServiceOfferingIcons(limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of ServiceInstance objects
         * @summary List ServiceInstances for ServiceOffering
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceOfferingServiceInstances(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listServiceOfferingServiceInstances(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of ServicePlan objects
         * @summary List ServicePlans for ServiceOffering
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceOfferingServicePlans(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listServiceOfferingServicePlans(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of Tag objects
         * @summary List Tags for ServiceOffering
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceOfferingTags(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listServiceOfferingTags(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of ServiceOffering objects
         * @summary List ServiceOfferings
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceOfferings(limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listServiceOfferings(limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of ServiceInstance objects
         * @summary List ServiceInstances for ServicePlan
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServicePlanServiceInstances(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listServicePlanServiceInstances(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of ServicePlan objects
         * @summary List ServicePlans
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServicePlans(limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listServicePlans(limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of Availability objects
         * @summary List Availabilities for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceAvailabilities(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listSourceAvailabilities(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of ContainerGroup objects
         * @summary List ContainerGroups for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceContainerGroups(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listSourceContainerGroups(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of ContainerImage objects
         * @summary List ContainerImages for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceContainerImages(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listSourceContainerImages(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of ContainerNode objects
         * @summary List ContainerNodes for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceContainerNodes(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listSourceContainerNodes(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of ContainerProject objects
         * @summary List ContainerProjects for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceContainerProjects(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listSourceContainerProjects(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of ContainerTemplate objects
         * @summary List ContainerTemplates for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceContainerTemplates(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listSourceContainerTemplates(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of Container objects
         * @summary List Containers for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceContainers(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listSourceContainers(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of OrchestrationStack objects
         * @summary List OrchestrationStacks for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceOrchestrationStacks(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listSourceOrchestrationStacks(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of ServiceInstance objects
         * @summary List ServiceInstances for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceServiceInstances(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listSourceServiceInstances(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of ServiceOffering objects
         * @summary List ServiceOfferings for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceServiceOfferings(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listSourceServiceOfferings(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of ServicePlan objects
         * @summary List ServicePlans for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceServicePlans(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listSourceServicePlans(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of Vm objects
         * @summary List Vms for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceVms(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listSourceVms(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of VolumeType objects
         * @summary List VolumeTypes for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceVolumeTypes(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listSourceVolumeTypes(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of Volume objects
         * @summary List Volumes for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceVolumes(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listSourceVolumes(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of Source objects
         * @summary List Sources
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSources(limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listSources(limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of ContainerGroup objects
         * @summary List ContainerGroups for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagContainerGroups(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listTagContainerGroups(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of ContainerImage objects
         * @summary List ContainerImages for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagContainerImages(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listTagContainerImages(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of ContainerNode objects
         * @summary List ContainerNodes for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagContainerNodes(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listTagContainerNodes(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of ContainerProject objects
         * @summary List ContainerProjects for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagContainerProjects(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listTagContainerProjects(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of ContainerTemplate objects
         * @summary List ContainerTemplates for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagContainerTemplates(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listTagContainerTemplates(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of ServiceOffering objects
         * @summary List ServiceOfferings for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagServiceOfferings(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listTagServiceOfferings(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of Vm objects
         * @summary List Vms for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagVms(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listTagVms(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of Tag objects
         * @summary List Tags
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTags(limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listTags(limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of Task objects
         * @summary List Tasks
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTasks(limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listTasks(limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of Tag objects
         * @summary List Tags for Vm
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVmTags(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listVmTags(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of VolumeAttachment objects
         * @summary List VolumeAttachments for Vm
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVmVolumeAttachments(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listVmVolumeAttachments(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of Volume objects
         * @summary List Volumes for Vm
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVmVolumes(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listVmVolumes(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of Vm objects
         * @summary List Vms
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVms(limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listVms(limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of VolumeAttachment objects
         * @summary List VolumeAttachments
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolumeAttachments(limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listVolumeAttachments(limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of VolumeType objects
         * @summary List VolumeTypes
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolumeTypes(limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listVolumeTypes(limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of Volume objects
         * @summary List Volumes
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolumes(limit?: number, offset?: number, filter?: any, options?: any) {
            return DefaultApiFp(configuration).listVolumes(limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns a Task id
         * @summary Order an existing ServicePlan
         * @param {string} id ID of the resource
         * @param {OrderParameters} orderParameters Order parameters defining the service and provider control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderServicePlan(id: string, orderParameters: OrderParameters, options?: any) {
            return DefaultApiFp(configuration).orderServicePlan(id, orderParameters, options)(axios, basePath);
        },
        /**
         * Performs a GraphQL Query
         * @summary Perform a GraphQL Query
         * @param {InlineObject} inlineObject
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGraphQL(inlineObject: InlineObject, options?: any) {
            return DefaultApiFp(configuration).postGraphQL(inlineObject, options)(axios, basePath);
        },
        /**
         * Returns a Container object
         * @summary Show an existing Container
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showContainer(id: string, options?: any) {
            return DefaultApiFp(configuration).showContainer(id, options)(axios, basePath);
        },
        /**
         * Returns a ContainerGroup object
         * @summary Show an existing ContainerGroup
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showContainerGroup(id: string, options?: any) {
            return DefaultApiFp(configuration).showContainerGroup(id, options)(axios, basePath);
        },
        /**
         * Returns a ContainerImage object
         * @summary Show an existing ContainerImage
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showContainerImage(id: string, options?: any) {
            return DefaultApiFp(configuration).showContainerImage(id, options)(axios, basePath);
        },
        /**
         * Returns a ContainerNode object
         * @summary Show an existing ContainerNode
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showContainerNode(id: string, options?: any) {
            return DefaultApiFp(configuration).showContainerNode(id, options)(axios, basePath);
        },
        /**
         * Returns a ContainerProject object
         * @summary Show an existing ContainerProject
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showContainerProject(id: string, options?: any) {
            return DefaultApiFp(configuration).showContainerProject(id, options)(axios, basePath);
        },
        /**
         * Returns a ContainerResourceQuota object
         * @summary Show an existing ContainerResourceQuota
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showContainerResourceQuota(id: string, options?: any) {
            return DefaultApiFp(configuration).showContainerResourceQuota(id, options)(axios, basePath);
        },
        /**
         * Returns a ContainerTemplate object
         * @summary Show an existing ContainerTemplate
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showContainerTemplate(id: string, options?: any) {
            return DefaultApiFp(configuration).showContainerTemplate(id, options)(axios, basePath);
        },
        /**
         * Returns a Flavor object
         * @summary Show an existing Flavor
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showFlavor(id: string, options?: any) {
            return DefaultApiFp(configuration).showFlavor(id, options)(axios, basePath);
        },
        /**
         * Returns a OrchestrationStack object
         * @summary Show an existing OrchestrationStack
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showOrchestrationStack(id: string, options?: any) {
            return DefaultApiFp(configuration).showOrchestrationStack(id, options)(axios, basePath);
        },
        /**
         * Returns a ServiceInstance object
         * @summary Show an existing ServiceInstance
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServiceInstance(id: string, options?: any) {
            return DefaultApiFp(configuration).showServiceInstance(id, options)(axios, basePath);
        },
        /**
         * Returns a ServiceOffering object
         * @summary Show an existing ServiceOffering
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServiceOffering(id: string, options?: any) {
            return DefaultApiFp(configuration).showServiceOffering(id, options)(axios, basePath);
        },
        /**
         * Returns a ServiceOfferingIcon object
         * @summary Show an existing ServiceOfferingIcon
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServiceOfferingIcon(id: string, options?: any) {
            return DefaultApiFp(configuration).showServiceOfferingIcon(id, options)(axios, basePath);
        },
        /**
         * Returns a ServiceOfferingIcon IconData
         * @summary Show an existing ServiceOfferingIcon IconData
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServiceOfferingIconIconData(id: string, options?: any) {
            return DefaultApiFp(configuration).showServiceOfferingIconIconData(id, options)(axios, basePath);
        },
        /**
         * Returns a ServicePlan object
         * @summary Show an existing ServicePlan
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServicePlan(id: string, options?: any) {
            return DefaultApiFp(configuration).showServicePlan(id, options)(axios, basePath);
        },
        /**
         * Returns a Source object
         * @summary Show an existing Source
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showSource(id: string, options?: any) {
            return DefaultApiFp(configuration).showSource(id, options)(axios, basePath);
        },
        /**
         * Returns a Tag object
         * @summary Show an existing Tag
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showTag(id: string, options?: any) {
            return DefaultApiFp(configuration).showTag(id, options)(axios, basePath);
        },
        /**
         * Returns a Task object
         * @summary Show an existing Task
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showTask(id: string, options?: any) {
            return DefaultApiFp(configuration).showTask(id, options)(axios, basePath);
        },
        /**
         * Returns a Vm object
         * @summary Show an existing Vm
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showVm(id: string, options?: any) {
            return DefaultApiFp(configuration).showVm(id, options)(axios, basePath);
        },
        /**
         * Returns a Volume object
         * @summary Show an existing Volume
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showVolume(id: string, options?: any) {
            return DefaultApiFp(configuration).showVolume(id, options)(axios, basePath);
        },
        /**
         * Returns a VolumeAttachment object
         * @summary Show an existing VolumeAttachment
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showVolumeAttachment(id: string, options?: any) {
            return DefaultApiFp(configuration).showVolumeAttachment(id, options)(axios, basePath);
        },
        /**
         * Returns a VolumeType object
         * @summary Show an existing VolumeType
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showVolumeType(id: string, options?: any) {
            return DefaultApiFp(configuration).showVolumeType(id, options)(axios, basePath);
        },
        /**
         * Updates a Task object
         * @summary Update an existing Task
         * @param {string} id ID of the resource
         * @param {Task} task Task attributes to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTask(id: string, task: Task, options?: any) {
            return DefaultApiFp(configuration).updateTask(id, task, options)(axios, basePath);
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     *
     * @summary Return this API document in JSON format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getDocumentation(options?: any) {
        return DefaultApiFp(this.configuration).getDocumentation(options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of Container objects
     * @summary List Containers for ContainerGroup
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listContainerGroupContainers(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listContainerGroupContainers(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of Tag objects
     * @summary List Tags for ContainerGroup
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listContainerGroupTags(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listContainerGroupTags(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of ContainerGroup objects
     * @summary List ContainerGroups
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listContainerGroups(limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listContainerGroups(limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of Tag objects
     * @summary List Tags for ContainerImage
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listContainerImageTags(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listContainerImageTags(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of ContainerImage objects
     * @summary List ContainerImages
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listContainerImages(limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listContainerImages(limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of ContainerGroup objects
     * @summary List ContainerGroups for ContainerNode
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listContainerNodeContainerGroups(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listContainerNodeContainerGroups(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of Tag objects
     * @summary List Tags for ContainerNode
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listContainerNodeTags(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listContainerNodeTags(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of ContainerNode objects
     * @summary List ContainerNodes
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listContainerNodes(limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listContainerNodes(limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of ContainerGroup objects
     * @summary List ContainerGroups for ContainerProject
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listContainerProjectContainerGroups(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listContainerProjectContainerGroups(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of ContainerResourceQuota objects
     * @summary List ContainerResourceQuota for ContainerProject
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listContainerProjectContainerResourceQuota(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listContainerProjectContainerResourceQuota(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of ContainerTemplate objects
     * @summary List ContainerTemplates for ContainerProject
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listContainerProjectContainerTemplates(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listContainerProjectContainerTemplates(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of Tag objects
     * @summary List Tags for ContainerProject
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listContainerProjectTags(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listContainerProjectTags(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of ContainerProject objects
     * @summary List ContainerProjects
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listContainerProjects(limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listContainerProjects(limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of ContainerResourceQuota objects
     * @summary List ContainerResourceQuota
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listContainerResourceQuota(limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listContainerResourceQuota(limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of Tag objects
     * @summary List Tags for ContainerTemplate
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listContainerTemplateTags(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listContainerTemplateTags(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of ContainerTemplate objects
     * @summary List ContainerTemplates
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listContainerTemplates(limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listContainerTemplates(limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of Container objects
     * @summary List Containers
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listContainers(limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listContainers(limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of Flavor objects
     * @summary List Flavors
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listFlavors(limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listFlavors(limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of OrchestrationStack objects
     * @summary List OrchestrationStacks
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listOrchestrationStacks(limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listOrchestrationStacks(limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of ServiceInstance objects
     * @summary List ServiceInstances
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listServiceInstances(limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listServiceInstances(limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of ServiceOfferingIcon objects
     * @summary List ServiceOfferingIcons
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listServiceOfferingIcons(limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listServiceOfferingIcons(limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of ServiceInstance objects
     * @summary List ServiceInstances for ServiceOffering
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listServiceOfferingServiceInstances(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listServiceOfferingServiceInstances(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of ServicePlan objects
     * @summary List ServicePlans for ServiceOffering
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listServiceOfferingServicePlans(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listServiceOfferingServicePlans(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of Tag objects
     * @summary List Tags for ServiceOffering
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listServiceOfferingTags(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listServiceOfferingTags(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of ServiceOffering objects
     * @summary List ServiceOfferings
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listServiceOfferings(limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listServiceOfferings(limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of ServiceInstance objects
     * @summary List ServiceInstances for ServicePlan
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listServicePlanServiceInstances(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listServicePlanServiceInstances(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of ServicePlan objects
     * @summary List ServicePlans
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listServicePlans(limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listServicePlans(limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of Availability objects
     * @summary List Availabilities for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceAvailabilities(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listSourceAvailabilities(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of ContainerGroup objects
     * @summary List ContainerGroups for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceContainerGroups(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listSourceContainerGroups(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of ContainerImage objects
     * @summary List ContainerImages for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceContainerImages(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listSourceContainerImages(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of ContainerNode objects
     * @summary List ContainerNodes for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceContainerNodes(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listSourceContainerNodes(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of ContainerProject objects
     * @summary List ContainerProjects for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceContainerProjects(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listSourceContainerProjects(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of ContainerTemplate objects
     * @summary List ContainerTemplates for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceContainerTemplates(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listSourceContainerTemplates(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of Container objects
     * @summary List Containers for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceContainers(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listSourceContainers(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of OrchestrationStack objects
     * @summary List OrchestrationStacks for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceOrchestrationStacks(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listSourceOrchestrationStacks(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of ServiceInstance objects
     * @summary List ServiceInstances for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceServiceInstances(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listSourceServiceInstances(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of ServiceOffering objects
     * @summary List ServiceOfferings for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceServiceOfferings(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listSourceServiceOfferings(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of ServicePlan objects
     * @summary List ServicePlans for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceServicePlans(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listSourceServicePlans(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of Vm objects
     * @summary List Vms for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceVms(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listSourceVms(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of VolumeType objects
     * @summary List VolumeTypes for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceVolumeTypes(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listSourceVolumeTypes(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of Volume objects
     * @summary List Volumes for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceVolumes(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listSourceVolumes(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of Source objects
     * @summary List Sources
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSources(limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listSources(limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of ContainerGroup objects
     * @summary List ContainerGroups for Tag
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listTagContainerGroups(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listTagContainerGroups(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of ContainerImage objects
     * @summary List ContainerImages for Tag
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listTagContainerImages(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listTagContainerImages(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of ContainerNode objects
     * @summary List ContainerNodes for Tag
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listTagContainerNodes(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listTagContainerNodes(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of ContainerProject objects
     * @summary List ContainerProjects for Tag
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listTagContainerProjects(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listTagContainerProjects(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of ContainerTemplate objects
     * @summary List ContainerTemplates for Tag
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listTagContainerTemplates(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listTagContainerTemplates(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of ServiceOffering objects
     * @summary List ServiceOfferings for Tag
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listTagServiceOfferings(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listTagServiceOfferings(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of Vm objects
     * @summary List Vms for Tag
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listTagVms(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listTagVms(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of Tag objects
     * @summary List Tags
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listTags(limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listTags(limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of Task objects
     * @summary List Tasks
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listTasks(limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listTasks(limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of Tag objects
     * @summary List Tags for Vm
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listVmTags(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listVmTags(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of VolumeAttachment objects
     * @summary List VolumeAttachments for Vm
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listVmVolumeAttachments(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listVmVolumeAttachments(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of Volume objects
     * @summary List Volumes for Vm
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listVmVolumes(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listVmVolumes(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of Vm objects
     * @summary List Vms
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listVms(limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listVms(limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of VolumeAttachment objects
     * @summary List VolumeAttachments
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listVolumeAttachments(limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listVolumeAttachments(limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of VolumeType objects
     * @summary List VolumeTypes
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listVolumeTypes(limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listVolumeTypes(limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of Volume objects
     * @summary List Volumes
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listVolumes(limit?: number, offset?: number, filter?: any, options?: any) {
        return DefaultApiFp(this.configuration).listVolumes(limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns a Task id
     * @summary Order an existing ServicePlan
     * @param {string} id ID of the resource
     * @param {OrderParameters} orderParameters Order parameters defining the service and provider control
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public orderServicePlan(id: string, orderParameters: OrderParameters, options?: any) {
        return DefaultApiFp(this.configuration).orderServicePlan(id, orderParameters, options)(this.axios, this.basePath);
    }

    /**
     * Performs a GraphQL Query
     * @summary Perform a GraphQL Query
     * @param {InlineObject} inlineObject
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postGraphQL(inlineObject: InlineObject, options?: any) {
        return DefaultApiFp(this.configuration).postGraphQL(inlineObject, options)(this.axios, this.basePath);
    }

    /**
     * Returns a Container object
     * @summary Show an existing Container
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showContainer(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showContainer(id, options)(this.axios, this.basePath);
    }

    /**
     * Returns a ContainerGroup object
     * @summary Show an existing ContainerGroup
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showContainerGroup(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showContainerGroup(id, options)(this.axios, this.basePath);
    }

    /**
     * Returns a ContainerImage object
     * @summary Show an existing ContainerImage
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showContainerImage(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showContainerImage(id, options)(this.axios, this.basePath);
    }

    /**
     * Returns a ContainerNode object
     * @summary Show an existing ContainerNode
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showContainerNode(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showContainerNode(id, options)(this.axios, this.basePath);
    }

    /**
     * Returns a ContainerProject object
     * @summary Show an existing ContainerProject
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showContainerProject(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showContainerProject(id, options)(this.axios, this.basePath);
    }

    /**
     * Returns a ContainerResourceQuota object
     * @summary Show an existing ContainerResourceQuota
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showContainerResourceQuota(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showContainerResourceQuota(id, options)(this.axios, this.basePath);
    }

    /**
     * Returns a ContainerTemplate object
     * @summary Show an existing ContainerTemplate
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showContainerTemplate(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showContainerTemplate(id, options)(this.axios, this.basePath);
    }

    /**
     * Returns a Flavor object
     * @summary Show an existing Flavor
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showFlavor(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showFlavor(id, options)(this.axios, this.basePath);
    }

    /**
     * Returns a OrchestrationStack object
     * @summary Show an existing OrchestrationStack
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showOrchestrationStack(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showOrchestrationStack(id, options)(this.axios, this.basePath);
    }

    /**
     * Returns a ServiceInstance object
     * @summary Show an existing ServiceInstance
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showServiceInstance(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showServiceInstance(id, options)(this.axios, this.basePath);
    }

    /**
     * Returns a ServiceOffering object
     * @summary Show an existing ServiceOffering
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showServiceOffering(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showServiceOffering(id, options)(this.axios, this.basePath);
    }

    /**
     * Returns a ServiceOfferingIcon object
     * @summary Show an existing ServiceOfferingIcon
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showServiceOfferingIcon(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showServiceOfferingIcon(id, options)(this.axios, this.basePath);
    }

    /**
     * Returns a ServiceOfferingIcon IconData
     * @summary Show an existing ServiceOfferingIcon IconData
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showServiceOfferingIconIconData(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showServiceOfferingIconIconData(id, options)(this.axios, this.basePath);
    }

    /**
     * Returns a ServicePlan object
     * @summary Show an existing ServicePlan
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showServicePlan(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showServicePlan(id, options)(this.axios, this.basePath);
    }

    /**
     * Returns a Source object
     * @summary Show an existing Source
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showSource(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showSource(id, options)(this.axios, this.basePath);
    }

    /**
     * Returns a Tag object
     * @summary Show an existing Tag
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showTag(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showTag(id, options)(this.axios, this.basePath);
    }

    /**
     * Returns a Task object
     * @summary Show an existing Task
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showTask(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showTask(id, options)(this.axios, this.basePath);
    }

    /**
     * Returns a Vm object
     * @summary Show an existing Vm
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showVm(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showVm(id, options)(this.axios, this.basePath);
    }

    /**
     * Returns a Volume object
     * @summary Show an existing Volume
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showVolume(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showVolume(id, options)(this.axios, this.basePath);
    }

    /**
     * Returns a VolumeAttachment object
     * @summary Show an existing VolumeAttachment
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showVolumeAttachment(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showVolumeAttachment(id, options)(this.axios, this.basePath);
    }

    /**
     * Returns a VolumeType object
     * @summary Show an existing VolumeType
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showVolumeType(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showVolumeType(id, options)(this.axios, this.basePath);
    }

    /**
     * Updates a Task object
     * @summary Update an existing Task
     * @param {string} id ID of the resource
     * @param {Task} task Task attributes to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateTask(id: string, task: Task, options?: any) {
        return DefaultApiFp(this.configuration).updateTask(id, task, options)(this.axios, this.basePath);
    }

}

