// tslint:disable
/// <reference path="./custom.d.ts" />
/**
 * Catalog API
 * This API gets and orders catalog items from different cloud sources.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: support@redhat.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';

const BASE_PATH = "https://cloud.redhat.com//api/catalog/v1.0".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface RequestArgs
 */
export interface RequestArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration | undefined;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected axios: AxiosInstance = globalAxios) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 *
 * @export
 * @interface AddPortfolioItem
 */
export interface AddPortfolioItem {
    /**
     * This is the ID of the portfolio item object.
     * @type {string}
     * @memberof AddPortfolioItem
     */
    portfolioItemId?: string;
}

/**
 *
 * @export
 * @interface ApprovalRequest
 */
export interface ApprovalRequest {
    /**
     * The unique identifier for this approval request.
     * @type {string}
     * @memberof ApprovalRequest
     */
    id?: string;
    /**
     * The id of the approval submitted to approval-api
     * @type {string}
     * @memberof ApprovalRequest
     */
    approvalRequestRef?: string;
    /**
     * The Order Item which the approval request belongs to
     * @type {string}
     * @memberof ApprovalRequest
     */
    orderItemId?: string;
    /**
     * The reason for the current state.
     * @type {string}
     * @memberof ApprovalRequest
     */
    reason?: string;
    /**
     * The state of the approval request (approved, denied, undecided)
     * @type {string}
     * @memberof ApprovalRequest
     */
    state?: ApprovalRequest.StateEnum;
    /**
     * The workflow that was requested
     * @type {string}
     * @memberof ApprovalRequest
     */
    workflowRef?: string;
}

/**
 * @export
 * @namespace ApprovalRequest
 */
export namespace ApprovalRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        Undecided = 'undecided',
        Approved = 'approved',
        Denied = 'denied'
    }
}

/**
 *
 * @export
 * @interface ApprovalRequestsCollection
 */
export interface ApprovalRequestsCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof ApprovalRequestsCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof ApprovalRequestsCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<ApprovalRequest>}
     * @memberof ApprovalRequestsCollection
     */
    data?: Array<ApprovalRequest>;
}

/**
 *
 * @export
 * @interface CollectionLinks
 */
export interface CollectionLinks {
    /**
     * The link to fetch the first group of items in the result set
     * @type {string}
     * @memberof CollectionLinks
     */
    first?: string;
    /**
     * The link to fetch the last group of items in the result set
     * @type {string}
     * @memberof CollectionLinks
     */
    last?: string;
    /**
     * The link to fetch the previous group of items in the result set
     * @type {string}
     * @memberof CollectionLinks
     */
    prev?: string;
    /**
     * The link to fetch the next group of items in the result set
     * @type {string}
     * @memberof CollectionLinks
     */
    next?: string;
}

/**
 *
 * @export
 * @interface CollectionMetadata
 */
export interface CollectionMetadata {
    /**
     * Total number of items in the result set, of which only a subset is returned, defined by the QueryLimit parameter.
     * @type {number}
     * @memberof CollectionMetadata
     */
    count?: number;
}

/**
 *
 * @export
 * @interface CopyPortfolioItem
 */
export interface CopyPortfolioItem {
    /**
     * The portfolio to place the new copy of the Portfolio Item in
     * @type {string}
     * @memberof CopyPortfolioItem
     */
    portfolioId?: string;
    /**
     * The name of the copied portfolio item
     * @type {string}
     * @memberof CopyPortfolioItem
     */
    portfolioItemName?: string;
}

/**
 *
 * @export
 * @interface CreatePortfolioItem
 */
export interface CreatePortfolioItem {
    /**
     * The service offering ref should be retrieved from a call to the Topology Service.
     * @type {string}
     * @memberof CreatePortfolioItem
     */
    serviceOfferingRef?: string;
}

/**
 *
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * The GraphQL query
     * @type {string}
     * @memberof InlineObject
     */
    query: string;
    /**
     * If the Query contains several named operations, the operationName controls which one should be executed
     * @type {string}
     * @memberof InlineObject
     */
    operationName?: string;
    /**
     * Optional Query variables
     * @type {any}
     * @memberof InlineObject
     */
    variables?: any;
}

/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * Results from the GraphQL query
     * @type {any}
     * @memberof InlineResponse200
     */
    data?: any;
    /**
     * Errors resulting from the GraphQL query
     * @type {Array<any>}
     * @memberof InlineResponse200
     */
    errors?: Array<any>;
}

/**
 *
 * @export
 * @interface Order
 */
export interface Order {
    /**
     *
     * @type {string}
     * @memberof Order
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof Order
     */
    userId?: string;
    /**
     * Current State of the order.
     * @type {string}
     * @memberof Order
     */
    state?: Order.StateEnum;
    /**
     *
     * @type {Date}
     * @memberof Order
     */
    createdAt?: Date;
    /**
     *
     * @type {Date}
     * @memberof Order
     */
    orderedAt?: Date;
    /**
     *
     * @type {Date}
     * @memberof Order
     */
    completedAt?: Date;
    /**
     *
     * @type {string}
     * @memberof Order
     */
    owner?: string;
}

/**
 * @export
 * @namespace Order
 */
export namespace Order {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        Created = 'Created',
        ApprovalPending = 'Approval Pending',
        Ordered = 'Ordered',
        Failed = 'Failed',
        Completed = 'Completed'
    }
}

/**
 *
 * @export
 * @interface OrderItem
 */
export interface OrderItem {
    /**
     *
     * @type {string}
     * @memberof OrderItem
     */
    id?: string;
    /**
     *
     * @type {number}
     * @memberof OrderItem
     */
    count: number;
    /**
     *
     * @type {any}
     * @memberof OrderItem
     */
    serviceParameters: any;
    /**
     * The provider specific parameters needed to provision this service. This might include namespaces, special keys.
     * @type {any}
     * @memberof OrderItem
     */
    providerControlParameters: any;
    /**
     * Stores the service plan ref from the Topology Service.
     * @type {string}
     * @memberof OrderItem
     */
    servicePlanRef: string;
    /**
     * Stores the Portfolio Item ID.
     * @type {string}
     * @memberof OrderItem
     */
    portfolioItemId: string;
    /**
     * Current state of this order item.
     * @type {string}
     * @memberof OrderItem
     */
    state?: OrderItem.StateEnum;
    /**
     * The Order that the OrderItem belongs to.
     * @type {string}
     * @memberof OrderItem
     */
    orderId?: string;
    /**
     *
     * @type {Date}
     * @memberof OrderItem
     */
    createdAt?: Date;
    /**
     *
     * @type {Date}
     * @memberof OrderItem
     */
    orderedAt?: Date;
    /**
     *
     * @type {Date}
     * @memberof OrderItem
     */
    completedAt?: Date;
    /**
     *
     * @type {Date}
     * @memberof OrderItem
     */
    updatedAt?: Date;
    /**
     *
     * @type {string}
     * @memberof OrderItem
     */
    owner?: string;
    /**
     * The external url of the service instance used with relation to this order item
     * @type {string}
     * @memberof OrderItem
     */
    externalUrl?: string;
    /**
     * The insights request id can be used to collect log data for this order item as its processed by the system
     * @type {string}
     * @memberof OrderItem
     */
    insightsRequestId?: string;
}

/**
 * @export
 * @namespace OrderItem
 */
export namespace OrderItem {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        Created = 'Created',
        ApprovalPending = 'Approval Pending',
        Ordered = 'Ordered',
        Failed = 'Failed',
        Completed = 'Completed',
        Approved = 'Approved',
        Denied = 'Denied'
    }
}

/**
 *
 * @export
 * @interface OrderItemsCollection
 */
export interface OrderItemsCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof OrderItemsCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof OrderItemsCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<OrderItem>}
     * @memberof OrderItemsCollection
     */
    data?: Array<OrderItem>;
}

/**
 *
 * @export
 * @interface OrdersCollection
 */
export interface OrdersCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof OrdersCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof OrdersCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<Order>}
     * @memberof OrdersCollection
     */
    data?: Array<Order>;
}

/**
 *
 * @export
 * @interface Portfolio
 */
export interface Portfolio {
    /**
     *
     * @type {string}
     * @memberof Portfolio
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof Portfolio
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof Portfolio
     */
    description: string;
    /**
     *
     * @type {boolean}
     * @memberof Portfolio
     */
    enabled?: boolean;
    /**
     *
     * @type {string}
     * @memberof Portfolio
     */
    imageUrl?: string;
    /**
     *
     * @type {string}
     * @memberof Portfolio
     */
    workflowRef?: string;
    /**
     *
     * @type {string}
     * @memberof Portfolio
     */
    owner?: string;
    /**
     *
     * @type {Date}
     * @memberof Portfolio
     */
    createdAt?: Date;
    /**
     *
     * @type {Date}
     * @memberof Portfolio
     */
    updatedAt?: Date;
}

/**
 *
 * @export
 * @interface PortfolioItem
 */
export interface PortfolioItem {
    /**
     *
     * @type {string}
     * @memberof PortfolioItem
     */
    id?: string;
    /**
     *
     * @type {boolean}
     * @memberof PortfolioItem
     */
    favorite?: boolean;
    /**
     *
     * @type {string}
     * @memberof PortfolioItem
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof PortfolioItem
     */
    description?: string;
    /**
     *
     * @type {boolean}
     * @memberof PortfolioItem
     */
    orphan?: boolean;
    /**
     *
     * @type {string}
     * @memberof PortfolioItem
     */
    state?: string;
    /**
     *
     * @type {string}
     * @memberof PortfolioItem
     */
    displayName?: string;
    /**
     *
     * @type {string}
     * @memberof PortfolioItem
     */
    longDescription?: string;
    /**
     *
     * @type {string}
     * @memberof PortfolioItem
     */
    distributor?: string;
    /**
     *
     * @type {string}
     * @memberof PortfolioItem
     */
    documentationUrl?: string;
    /**
     *
     * @type {string}
     * @memberof PortfolioItem
     */
    supportUrl?: string;
    /**
     *
     * @type {string}
     * @memberof PortfolioItem
     */
    workflowRef?: string;
    /**
     *
     * @type {string}
     * @memberof PortfolioItem
     */
    owner?: string;
    /**
     *
     * @type {string}
     * @memberof PortfolioItem
     */
    serviceOfferingIconRef?: string;
    /**
     * The source reference this product was created from
     * @type {string}
     * @memberof PortfolioItem
     */
    serviceOfferingSourceRef?: string;
    /**
     *
     * @type {Date}
     * @memberof PortfolioItem
     */
    createdAt?: Date;
    /**
     *
     * @type {Date}
     * @memberof PortfolioItem
     */
    updatedAt?: Date;
}

/**
 *
 * @export
 * @interface PortfolioItemsCollection
 */
export interface PortfolioItemsCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof PortfolioItemsCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof PortfolioItemsCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<PortfolioItem>}
     * @memberof PortfolioItemsCollection
     */
    data?: Array<PortfolioItem>;
}

/**
 *
 * @export
 * @interface PortfoliosCollection
 */
export interface PortfoliosCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof PortfoliosCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof PortfoliosCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<Portfolio>}
     * @memberof PortfoliosCollection
     */
    data?: Array<Portfolio>;
}

/**
 *
 * @export
 * @interface ProgressMessage
 */
export interface ProgressMessage {
    /**
     *
     * @type {Date}
     * @memberof ProgressMessage
     */
    receivedAt?: Date;
    /**
     *
     * @type {string}
     * @memberof ProgressMessage
     */
    level?: ProgressMessage.LevelEnum;
    /**
     *
     * @type {string}
     * @memberof ProgressMessage
     */
    message?: string;
    /**
     *
     * @type {string}
     * @memberof ProgressMessage
     */
    orderItemId?: string;
}

/**
 * @export
 * @namespace ProgressMessage
 */
export namespace ProgressMessage {
    /**
     * @export
     * @enum {string}
     */
    export enum LevelEnum {
        Info = 'info',
        Error = 'error',
        Warning = 'warning',
        Debug = 'debug'
    }
}

/**
 *
 * @export
 * @interface ProgressMessagesCollection
 */
export interface ProgressMessagesCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof ProgressMessagesCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof ProgressMessagesCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<ProgressMessage>}
     * @memberof ProgressMessagesCollection
     */
    data?: Array<ProgressMessage>;
}

/**
 *
 * @export
 * @interface RestoreKey
 */
export interface RestoreKey {
    /**
     *
     * @type {string}
     * @memberof RestoreKey
     */
    restoreKey?: string;
}

/**
 *
 * @export
 * @interface ServiceOfferingIcon
 */
export interface ServiceOfferingIcon {
    /**
     * The unique identifier for this Service Offering Icon
     * @type {string}
     * @memberof ServiceOfferingIcon
     */
    id?: string;
    /**
     * The raw SVG data for this icon
     * @type {string}
     * @memberof ServiceOfferingIcon
     */
    data?: string;
    /**
     * Stores the Source Ref for this icon
     * @type {string}
     * @memberof ServiceOfferingIcon
     */
    sourceRef?: string;
}

/**
 *
 * @export
 * @interface ServicePlan
 */
export interface ServicePlan {
    /**
     * The name of the service plan.
     * @type {string}
     * @memberof ServicePlan
     */
    name?: string;
    /**
     * The service plan description.
     * @type {string}
     * @memberof ServicePlan
     */
    description?: string;
    /**
     * The unique identifier for this service plan.
     * @type {string}
     * @memberof ServicePlan
     */
    id?: string;
    /**
     * JSON schema for the object.
     * @type {any}
     * @memberof ServicePlan
     */
    createJsonSchema?: any;
}

/**
 *
 * @export
 * @interface ShareInfo
 */
export interface ShareInfo {
    /**
     * The Group UUID
     * @type {string}
     * @memberof ShareInfo
     */
    groupUuid?: string;
    /**
     * The Group Name
     * @type {string}
     * @memberof ShareInfo
     */
    groupName?: string;
    /**
     * One or more permissions currently applied to this group.
     * @type {Array<string>}
     * @memberof ShareInfo
     */
    permissions?: Array<string>;
}

/**
 *
 * @export
 * @interface SharePolicy
 */
export interface SharePolicy {
    /**
     * The permissions to apply for this share.
     * @type {Array<string>}
     * @memberof SharePolicy
     */
    permissions: Array<string>;
    /**
     * An array of group UUID's retrieved from the RBAC Service with whom the resource has to be shared.
     * @type {Array<string>}
     * @memberof SharePolicy
     */
    groupUuids: Array<string>;
}

/**
 *
 * @export
 * @interface UnsharePolicy
 */
export interface UnsharePolicy {
    /**
     * The permissions to remove for this resource.
     * @type {Array<string>}
     * @memberof UnsharePolicy
     */
    permissions: Array<string>;
    /**
     * An array of group UUID's retrieved from the RBAC Service from which the permissions have to be removed. If group uuids are not specified we will unshare it from all groups.
     * @type {Array<string>}
     * @memberof UnsharePolicy
     */
    groupUuids?: Array<string>;
}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Return this API document in JSON format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentation(options: any = {}): RequestArgs {
            const localVarPath = `/openapi.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs a GraphQL Query
         * @summary Perform a GraphQL Query
         * @param {InlineObject} inlineObject
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGraphQL(inlineObject: InlineObject, options: any = {}): RequestArgs {
            // verify required parameter 'inlineObject' is not null or undefined
            if (inlineObject === null || inlineObject === undefined) {
                throw new RequiredError('inlineObject','Required parameter inlineObject was null or undefined when calling postGraphQL.');
            }
            const localVarPath = `/graphql`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"InlineObject" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject || {}) : (inlineObject || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Return this API document in JSON format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentation(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).getDocumentation(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Performs a GraphQL Query
         * @summary Perform a GraphQL Query
         * @param {InlineObject} inlineObject
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGraphQL(inlineObject: InlineObject, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).postGraphQL(inlineObject, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @summary Return this API document in JSON format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentation(options?: any) {
            return DefaultApiFp(configuration).getDocumentation(options)(axios, basePath);
        },
        /**
         * Performs a GraphQL Query
         * @summary Perform a GraphQL Query
         * @param {InlineObject} inlineObject
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGraphQL(inlineObject: InlineObject, options?: any) {
            return DefaultApiFp(configuration).postGraphQL(inlineObject, options)(axios, basePath);
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     *
     * @summary Return this API document in JSON format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getDocumentation(options?: any) {
        return DefaultApiFp(this.configuration).getDocumentation(options)(this.axios, this.basePath);
    }

    /**
     * Performs a GraphQL Query
     * @summary Perform a GraphQL Query
     * @param {InlineObject} inlineObject
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postGraphQL(inlineObject: InlineObject, options?: any) {
        return DefaultApiFp(this.configuration).postGraphQL(inlineObject, options)(this.axios, this.basePath);
    }

}

/**
 * OrderApi - axios parameter creator
 * @export
 */
export const OrderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds an order item to an order in pending state
         * @summary Add an order item to an order in pending state
         * @param {string} orderId The Order ID
         * @param {OrderItem} orderItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToOrder(orderId: string, orderItem: OrderItem, options: any = {}): RequestArgs {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling addToOrder.');
            }
            // verify required parameter 'orderItem' is not null or undefined
            if (orderItem === null || orderItem === undefined) {
                throw new RequiredError('orderItem','Required parameter orderItem was null or undefined when calling addToOrder.');
            }
            const localVarPath = `/orders/{order_id}/order_items`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OrderItem" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(orderItem || {}) : (orderItem || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new order.
         * @summary Create a new order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder(options: any = {}): RequestArgs {
            const localVarPath = `/orders`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of items associated with an order.
         * @summary Gets a list of items in a given order
         * @param {string} orderId The Order ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrderItems(orderId: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling listOrderItems.');
            }
            const localVarPath = `/orders/{order_id}/order_items`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of orders associated with the logged in user.
         * @summary Get a list of orders
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrders(limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            const localVarPath = `/orders`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets an order item associated with an order.
         * @summary Gets an individual order item from a given order
         * @param {string} orderId The Order ID
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showOrderItem(orderId: string, id: string, options: any = {}): RequestArgs {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling showOrderItem.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showOrderItem.');
            }
            const localVarPath = `/orders/{order_id}/order_items/{id}`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an updated order.
         * @summary Submit a given order
         * @param {string} orderId The Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitOrder(orderId: string, options: any = {}): RequestArgs {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling submitOrder.');
            }
            const localVarPath = `/orders/{order_id}/submit_order`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderApi - functional programming interface
 * @export
 */
export const OrderApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds an order item to an order in pending state
         * @summary Add an order item to an order in pending state
         * @param {string} orderId The Order ID
         * @param {OrderItem} orderItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToOrder(orderId: string, orderItem: OrderItem, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = OrderApiAxiosParamCreator(configuration).addToOrder(orderId, orderItem, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a new order.
         * @summary Create a new order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order> {
            const localVarAxiosArgs = OrderApiAxiosParamCreator(configuration).createOrder(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a list of items associated with an order.
         * @summary Gets a list of items in a given order
         * @param {string} orderId The Order ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrderItems(orderId: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderItemsCollection> {
            const localVarAxiosArgs = OrderApiAxiosParamCreator(configuration).listOrderItems(orderId, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a list of orders associated with the logged in user.
         * @summary Get a list of orders
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrders(limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrdersCollection> {
            const localVarAxiosArgs = OrderApiAxiosParamCreator(configuration).listOrders(limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets an order item associated with an order.
         * @summary Gets an individual order item from a given order
         * @param {string} orderId The Order ID
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showOrderItem(orderId: string, id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderItem> {
            const localVarAxiosArgs = OrderApiAxiosParamCreator(configuration).showOrderItem(orderId, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an updated order.
         * @summary Submit a given order
         * @param {string} orderId The Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitOrder(orderId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order> {
            const localVarAxiosArgs = OrderApiAxiosParamCreator(configuration).submitOrder(orderId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OrderApi - factory interface
 * @export
 */
export const OrderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Adds an order item to an order in pending state
         * @summary Add an order item to an order in pending state
         * @param {string} orderId The Order ID
         * @param {OrderItem} orderItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToOrder(orderId: string, orderItem: OrderItem, options?: any) {
            return OrderApiFp(configuration).addToOrder(orderId, orderItem, options)(axios, basePath);
        },
        /**
         * Creates a new order.
         * @summary Create a new order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder(options?: any) {
            return OrderApiFp(configuration).createOrder(options)(axios, basePath);
        },
        /**
         * Gets a list of items associated with an order.
         * @summary Gets a list of items in a given order
         * @param {string} orderId The Order ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrderItems(orderId: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return OrderApiFp(configuration).listOrderItems(orderId, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Gets a list of orders associated with the logged in user.
         * @summary Get a list of orders
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrders(limit?: number, offset?: number, filter?: any, options?: any) {
            return OrderApiFp(configuration).listOrders(limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Gets an order item associated with an order.
         * @summary Gets an individual order item from a given order
         * @param {string} orderId The Order ID
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showOrderItem(orderId: string, id: string, options?: any) {
            return OrderApiFp(configuration).showOrderItem(orderId, id, options)(axios, basePath);
        },
        /**
         * Returns an updated order.
         * @summary Submit a given order
         * @param {string} orderId The Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitOrder(orderId: string, options?: any) {
            return OrderApiFp(configuration).submitOrder(orderId, options)(axios, basePath);
        },
    };
};

/**
 * OrderApi - object-oriented interface
 * @export
 * @class OrderApi
 * @extends {BaseAPI}
 */
export class OrderApi extends BaseAPI {
    /**
     * Adds an order item to an order in pending state
     * @summary Add an order item to an order in pending state
     * @param {string} orderId The Order ID
     * @param {OrderItem} orderItem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public addToOrder(orderId: string, orderItem: OrderItem, options?: any) {
        return OrderApiFp(this.configuration).addToOrder(orderId, orderItem, options)(this.axios, this.basePath);
    }

    /**
     * Creates a new order.
     * @summary Create a new order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public createOrder(options?: any) {
        return OrderApiFp(this.configuration).createOrder(options)(this.axios, this.basePath);
    }

    /**
     * Gets a list of items associated with an order.
     * @summary Gets a list of items in a given order
     * @param {string} orderId The Order ID
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public listOrderItems(orderId: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return OrderApiFp(this.configuration).listOrderItems(orderId, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Gets a list of orders associated with the logged in user.
     * @summary Get a list of orders
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public listOrders(limit?: number, offset?: number, filter?: any, options?: any) {
        return OrderApiFp(this.configuration).listOrders(limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Gets an order item associated with an order.
     * @summary Gets an individual order item from a given order
     * @param {string} orderId The Order ID
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public showOrderItem(orderId: string, id: string, options?: any) {
        return OrderApiFp(this.configuration).showOrderItem(orderId, id, options)(this.axios, this.basePath);
    }

    /**
     * Returns an updated order.
     * @summary Submit a given order
     * @param {string} orderId The Order ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public submitOrder(orderId: string, options?: any) {
        return OrderApiFp(this.configuration).submitOrder(orderId, options)(this.axios, this.basePath);
    }

}

/**
 * OrderItemApi - axios parameter creator
 * @export
 */
export const OrderItemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets a list of approval request associated with an order item. As the item is being approved one can check the status of the approvals.
         * @summary Gets a list of approval requests for an item
         * @param {string} orderItemId The Order Item ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApprovalRequests(orderItemId: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'orderItemId' is not null or undefined
            if (orderItemId === null || orderItemId === undefined) {
                throw new RequiredError('orderItemId','Required parameter orderItemId was null or undefined when calling listApprovalRequests.');
            }
            const localVarPath = `/order_items/{order_item_id}/approval_requests`
                .replace(`{${"order_item_id"}}`, encodeURIComponent(String(orderItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of order items.
         * @summary List Order Items
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrderItems(limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            const localVarPath = `/order_items`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of progress messages associated with an order item. As the item is being processed the provider can update the progress messages.
         * @summary Gets a list of progress messages in an item
         * @param {string} orderItemId The Order Item ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProgressMessages(orderItemId: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'orderItemId' is not null or undefined
            if (orderItemId === null || orderItemId === undefined) {
                throw new RequiredError('orderItemId','Required parameter orderItemId was null or undefined when calling listProgressMessages.');
            }
            const localVarPath = `/order_items/{order_item_id}/progress_messages`
                .replace(`{${"order_item_id"}}`, encodeURIComponent(String(orderItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific order item based on the portfolio item ID passed
         * @summary Gets a specific order item
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showOrderItem(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showOrderItem.');
            }
            const localVarPath = `/order_items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderItemApi - functional programming interface
 * @export
 */
export const OrderItemApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Gets a list of approval request associated with an order item. As the item is being approved one can check the status of the approvals.
         * @summary Gets a list of approval requests for an item
         * @param {string} orderItemId The Order Item ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApprovalRequests(orderItemId: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApprovalRequestsCollection> {
            const localVarAxiosArgs = OrderItemApiAxiosParamCreator(configuration).listApprovalRequests(orderItemId, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a list of order items.
         * @summary List Order Items
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrderItems(limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderItemsCollection> {
            const localVarAxiosArgs = OrderItemApiAxiosParamCreator(configuration).listOrderItems(limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a list of progress messages associated with an order item. As the item is being processed the provider can update the progress messages.
         * @summary Gets a list of progress messages in an item
         * @param {string} orderItemId The Order Item ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProgressMessages(orderItemId: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProgressMessagesCollection> {
            const localVarAxiosArgs = OrderItemApiAxiosParamCreator(configuration).listProgressMessages(orderItemId, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a specific order item based on the portfolio item ID passed
         * @summary Gets a specific order item
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showOrderItem(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderItem> {
            const localVarAxiosArgs = OrderItemApiAxiosParamCreator(configuration).showOrderItem(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OrderItemApi - factory interface
 * @export
 */
export const OrderItemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Gets a list of approval request associated with an order item. As the item is being approved one can check the status of the approvals.
         * @summary Gets a list of approval requests for an item
         * @param {string} orderItemId The Order Item ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApprovalRequests(orderItemId: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return OrderItemApiFp(configuration).listApprovalRequests(orderItemId, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Gets a list of order items.
         * @summary List Order Items
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrderItems(limit?: number, offset?: number, filter?: any, options?: any) {
            return OrderItemApiFp(configuration).listOrderItems(limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Gets a list of progress messages associated with an order item. As the item is being processed the provider can update the progress messages.
         * @summary Gets a list of progress messages in an item
         * @param {string} orderItemId The Order Item ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProgressMessages(orderItemId: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return OrderItemApiFp(configuration).listProgressMessages(orderItemId, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Gets a specific order item based on the portfolio item ID passed
         * @summary Gets a specific order item
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showOrderItem(id: string, options?: any) {
            return OrderItemApiFp(configuration).showOrderItem(id, options)(axios, basePath);
        },
    };
};

/**
 * OrderItemApi - object-oriented interface
 * @export
 * @class OrderItemApi
 * @extends {BaseAPI}
 */
export class OrderItemApi extends BaseAPI {
    /**
     * Gets a list of approval request associated with an order item. As the item is being approved one can check the status of the approvals.
     * @summary Gets a list of approval requests for an item
     * @param {string} orderItemId The Order Item ID
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderItemApi
     */
    public listApprovalRequests(orderItemId: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return OrderItemApiFp(this.configuration).listApprovalRequests(orderItemId, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Gets a list of order items.
     * @summary List Order Items
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderItemApi
     */
    public listOrderItems(limit?: number, offset?: number, filter?: any, options?: any) {
        return OrderItemApiFp(this.configuration).listOrderItems(limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Gets a list of progress messages associated with an order item. As the item is being processed the provider can update the progress messages.
     * @summary Gets a list of progress messages in an item
     * @param {string} orderItemId The Order Item ID
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderItemApi
     */
    public listProgressMessages(orderItemId: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return OrderItemApiFp(this.configuration).listProgressMessages(orderItemId, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Gets a specific order item based on the portfolio item ID passed
     * @summary Gets a specific order item
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderItemApi
     */
    public showOrderItem(id: string, options?: any) {
        return OrderItemApiFp(this.configuration).showOrderItem(id, options)(this.axios, this.basePath);
    }

}

/**
 * PortfolioApi - axios parameter creator
 * @export
 */
export const PortfolioApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new portfolio item to an existing portfolio.
         * @summary Add a portfolio item to a portfolio
         * @param {string} portfolioId The Portfolio ID
         * @param {AddPortfolioItem} addPortfolioItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPortfolioItemToPortfolio(portfolioId: string, addPortfolioItem: AddPortfolioItem, options: any = {}): RequestArgs {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling addPortfolioItemToPortfolio.');
            }
            // verify required parameter 'addPortfolioItem' is not null or undefined
            if (addPortfolioItem === null || addPortfolioItem === undefined) {
                throw new RequiredError('addPortfolioItem','Required parameter addPortfolioItem was null or undefined when calling addPortfolioItemToPortfolio.');
            }
            const localVarPath = `/portfolios/{portfolio_id}/portfolio_items`
                .replace(`{${"portfolio_id"}}`, encodeURIComponent(String(portfolioId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddPortfolioItem" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(addPortfolioItem || {}) : (addPortfolioItem || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a portfolio.
         * @summary Add a new portfolio
         * @param {Portfolio} portfolio Parameters needed to add a Portfolio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPortfolio(portfolio: Portfolio, options: any = {}): RequestArgs {
            // verify required parameter 'portfolio' is not null or undefined
            if (portfolio === null || portfolio === undefined) {
                throw new RequiredError('portfolio','Required parameter portfolio was null or undefined when calling createPortfolio.');
            }
            const localVarPath = `/portfolios`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Portfolio" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(portfolio || {}) : (portfolio || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the portfolio specified by the ID.
         * @summary Delete an existing portfolio
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyPortfolio(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling destroyPortfolio.');
            }
            const localVarPath = `/portfolios/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets all portfilio items in the portfolio specified by the given ID.
         * @summary Get all portfolio items from a specific portfolio
         * @param {string} portfolioId The Portfolio ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchPortfolioItemsWithPortfolio(portfolioId: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling fetchPortfolioItemsWithPortfolio.');
            }
            const localVarPath = `/portfolios/{portfolio_id}/portfolio_items`
                .replace(`{${"portfolio_id"}}`, encodeURIComponent(String(portfolioId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of portfolios.
         * @summary List portfolios
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPortfolios(limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            const localVarPath = `/portfolios`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Make a copy of the Portfolio.
         * @summary Make a copy of the Portfolio
         * @param {string} portfolioId The Portfolio ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCopyPortfolio(portfolioId: string, options: any = {}): RequestArgs {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling postCopyPortfolio.');
            }
            const localVarPath = `/portfolios/{portfolio_id}/copy`
                .replace(`{${"portfolio_id"}}`, encodeURIComponent(String(portfolioId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch share information about a portfolio
         * @summary Fetch share information about this portfolio, the response would include a collection of groups and permissions with each group
         * @param {string} portfolioId The Portfolio ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareInfo(portfolioId: string, options: any = {}): RequestArgs {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling shareInfo.');
            }
            const localVarPath = `/portfolios/{portfolio_id}/share_info`
                .replace(`{${"portfolio_id"}}`, encodeURIComponent(String(portfolioId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Share a Portfolio with one or more groups with specific permissions
         * @summary Share a portfolio with one or more groups with specific permission
         * @param {string} portfolioId The Portfolio ID
         * @param {SharePolicy} sharePolicy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharePortfolio(portfolioId: string, sharePolicy: SharePolicy, options: any = {}): RequestArgs {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling sharePortfolio.');
            }
            // verify required parameter 'sharePolicy' is not null or undefined
            if (sharePolicy === null || sharePolicy === undefined) {
                throw new RequiredError('sharePolicy','Required parameter sharePolicy was null or undefined when calling sharePortfolio.');
            }
            const localVarPath = `/portfolios/{portfolio_id}/share`
                .replace(`{${"portfolio_id"}}`, encodeURIComponent(String(portfolioId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SharePolicy" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(sharePolicy || {}) : (sharePolicy || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the portfolio specified by the portfolio ID.
         * @summary Get a specific portfolio
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showPortfolio(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showPortfolio.');
            }
            const localVarPath = `/portfolios/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Undeletes the portfolio specified by the portfolio ID.
         * @summary Undelete specific portfolio
         * @param {string} id ID of the resource
         * @param {RestoreKey} restoreKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unDeletePortfolio(id: string, restoreKey: RestoreKey, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling unDeletePortfolio.');
            }
            // verify required parameter 'restoreKey' is not null or undefined
            if (restoreKey === null || restoreKey === undefined) {
                throw new RequiredError('restoreKey','Required parameter restoreKey was null or undefined when calling unDeletePortfolio.');
            }
            const localVarPath = `/portfolios/{id}/undelete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RestoreKey" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(restoreKey || {}) : (restoreKey || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unshare a Portfolio with one or more groups with specific permissions
         * @summary Unshare a portfolio from one or more groups with specific permission
         * @param {string} portfolioId The Portfolio ID
         * @param {UnsharePolicy} unsharePolicy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsharePortfolio(portfolioId: string, unsharePolicy: UnsharePolicy, options: any = {}): RequestArgs {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling unsharePortfolio.');
            }
            // verify required parameter 'unsharePolicy' is not null or undefined
            if (unsharePolicy === null || unsharePolicy === undefined) {
                throw new RequiredError('unsharePolicy','Required parameter unsharePolicy was null or undefined when calling unsharePortfolio.');
            }
            const localVarPath = `/portfolios/{portfolio_id}/unshare`
                .replace(`{${"portfolio_id"}}`, encodeURIComponent(String(portfolioId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UnsharePolicy" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(unsharePolicy || {}) : (unsharePolicy || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the edited portfolio.
         * @summary Edit an existing portfolio
         * @param {string} id ID of the resource
         * @param {Portfolio} portfolio Parameters needed to update a Portfolio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolio(id: string, portfolio: Portfolio, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updatePortfolio.');
            }
            // verify required parameter 'portfolio' is not null or undefined
            if (portfolio === null || portfolio === undefined) {
                throw new RequiredError('portfolio','Required parameter portfolio was null or undefined when calling updatePortfolio.');
            }
            const localVarPath = `/portfolios/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Portfolio" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(portfolio || {}) : (portfolio || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PortfolioApi - functional programming interface
 * @export
 */
export const PortfolioApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds a new portfolio item to an existing portfolio.
         * @summary Add a portfolio item to a portfolio
         * @param {string} portfolioId The Portfolio ID
         * @param {AddPortfolioItem} addPortfolioItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPortfolioItemToPortfolio(portfolioId: string, addPortfolioItem: AddPortfolioItem, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = PortfolioApiAxiosParamCreator(configuration).addPortfolioItemToPortfolio(portfolioId, addPortfolioItem, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Adds a portfolio.
         * @summary Add a new portfolio
         * @param {Portfolio} portfolio Parameters needed to add a Portfolio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPortfolio(portfolio: Portfolio, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Portfolio> {
            const localVarAxiosArgs = PortfolioApiAxiosParamCreator(configuration).createPortfolio(portfolio, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes the portfolio specified by the ID.
         * @summary Delete an existing portfolio
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyPortfolio(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestoreKey> {
            const localVarAxiosArgs = PortfolioApiAxiosParamCreator(configuration).destroyPortfolio(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets all portfilio items in the portfolio specified by the given ID.
         * @summary Get all portfolio items from a specific portfolio
         * @param {string} portfolioId The Portfolio ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchPortfolioItemsWithPortfolio(portfolioId: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioItemsCollection> {
            const localVarAxiosArgs = PortfolioApiAxiosParamCreator(configuration).fetchPortfolioItemsWithPortfolio(portfolioId, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a list of portfolios.
         * @summary List portfolios
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPortfolios(limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfoliosCollection> {
            const localVarAxiosArgs = PortfolioApiAxiosParamCreator(configuration).listPortfolios(limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Make a copy of the Portfolio.
         * @summary Make a copy of the Portfolio
         * @param {string} portfolioId The Portfolio ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCopyPortfolio(portfolioId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Portfolio> {
            const localVarAxiosArgs = PortfolioApiAxiosParamCreator(configuration).postCopyPortfolio(portfolioId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch share information about a portfolio
         * @summary Fetch share information about this portfolio, the response would include a collection of groups and permissions with each group
         * @param {string} portfolioId The Portfolio ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareInfo(portfolioId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ShareInfo>> {
            const localVarAxiosArgs = PortfolioApiAxiosParamCreator(configuration).shareInfo(portfolioId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Share a Portfolio with one or more groups with specific permissions
         * @summary Share a portfolio with one or more groups with specific permission
         * @param {string} portfolioId The Portfolio ID
         * @param {SharePolicy} sharePolicy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharePortfolio(portfolioId: string, sharePolicy: SharePolicy, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = PortfolioApiAxiosParamCreator(configuration).sharePortfolio(portfolioId, sharePolicy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets the portfolio specified by the portfolio ID.
         * @summary Get a specific portfolio
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showPortfolio(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Portfolio> {
            const localVarAxiosArgs = PortfolioApiAxiosParamCreator(configuration).showPortfolio(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Undeletes the portfolio specified by the portfolio ID.
         * @summary Undelete specific portfolio
         * @param {string} id ID of the resource
         * @param {RestoreKey} restoreKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unDeletePortfolio(id: string, restoreKey: RestoreKey, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Portfolio> {
            const localVarAxiosArgs = PortfolioApiAxiosParamCreator(configuration).unDeletePortfolio(id, restoreKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Unshare a Portfolio with one or more groups with specific permissions
         * @summary Unshare a portfolio from one or more groups with specific permission
         * @param {string} portfolioId The Portfolio ID
         * @param {UnsharePolicy} unsharePolicy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsharePortfolio(portfolioId: string, unsharePolicy: UnsharePolicy, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = PortfolioApiAxiosParamCreator(configuration).unsharePortfolio(portfolioId, unsharePolicy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the edited portfolio.
         * @summary Edit an existing portfolio
         * @param {string} id ID of the resource
         * @param {Portfolio} portfolio Parameters needed to update a Portfolio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolio(id: string, portfolio: Portfolio, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Portfolio> {
            const localVarAxiosArgs = PortfolioApiAxiosParamCreator(configuration).updatePortfolio(id, portfolio, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PortfolioApi - factory interface
 * @export
 */
export const PortfolioApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Adds a new portfolio item to an existing portfolio.
         * @summary Add a portfolio item to a portfolio
         * @param {string} portfolioId The Portfolio ID
         * @param {AddPortfolioItem} addPortfolioItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPortfolioItemToPortfolio(portfolioId: string, addPortfolioItem: AddPortfolioItem, options?: any) {
            return PortfolioApiFp(configuration).addPortfolioItemToPortfolio(portfolioId, addPortfolioItem, options)(axios, basePath);
        },
        /**
         * Adds a portfolio.
         * @summary Add a new portfolio
         * @param {Portfolio} portfolio Parameters needed to add a Portfolio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPortfolio(portfolio: Portfolio, options?: any) {
            return PortfolioApiFp(configuration).createPortfolio(portfolio, options)(axios, basePath);
        },
        /**
         * Deletes the portfolio specified by the ID.
         * @summary Delete an existing portfolio
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyPortfolio(id: string, options?: any) {
            return PortfolioApiFp(configuration).destroyPortfolio(id, options)(axios, basePath);
        },
        /**
         * Gets all portfilio items in the portfolio specified by the given ID.
         * @summary Get all portfolio items from a specific portfolio
         * @param {string} portfolioId The Portfolio ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchPortfolioItemsWithPortfolio(portfolioId: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return PortfolioApiFp(configuration).fetchPortfolioItemsWithPortfolio(portfolioId, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Gets a list of portfolios.
         * @summary List portfolios
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPortfolios(limit?: number, offset?: number, filter?: any, options?: any) {
            return PortfolioApiFp(configuration).listPortfolios(limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Make a copy of the Portfolio.
         * @summary Make a copy of the Portfolio
         * @param {string} portfolioId The Portfolio ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCopyPortfolio(portfolioId: string, options?: any) {
            return PortfolioApiFp(configuration).postCopyPortfolio(portfolioId, options)(axios, basePath);
        },
        /**
         * Fetch share information about a portfolio
         * @summary Fetch share information about this portfolio, the response would include a collection of groups and permissions with each group
         * @param {string} portfolioId The Portfolio ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareInfo(portfolioId: string, options?: any) {
            return PortfolioApiFp(configuration).shareInfo(portfolioId, options)(axios, basePath);
        },
        /**
         * Share a Portfolio with one or more groups with specific permissions
         * @summary Share a portfolio with one or more groups with specific permission
         * @param {string} portfolioId The Portfolio ID
         * @param {SharePolicy} sharePolicy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharePortfolio(portfolioId: string, sharePolicy: SharePolicy, options?: any) {
            return PortfolioApiFp(configuration).sharePortfolio(portfolioId, sharePolicy, options)(axios, basePath);
        },
        /**
         * Gets the portfolio specified by the portfolio ID.
         * @summary Get a specific portfolio
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showPortfolio(id: string, options?: any) {
            return PortfolioApiFp(configuration).showPortfolio(id, options)(axios, basePath);
        },
        /**
         * Undeletes the portfolio specified by the portfolio ID.
         * @summary Undelete specific portfolio
         * @param {string} id ID of the resource
         * @param {RestoreKey} restoreKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unDeletePortfolio(id: string, restoreKey: RestoreKey, options?: any) {
            return PortfolioApiFp(configuration).unDeletePortfolio(id, restoreKey, options)(axios, basePath);
        },
        /**
         * Unshare a Portfolio with one or more groups with specific permissions
         * @summary Unshare a portfolio from one or more groups with specific permission
         * @param {string} portfolioId The Portfolio ID
         * @param {UnsharePolicy} unsharePolicy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsharePortfolio(portfolioId: string, unsharePolicy: UnsharePolicy, options?: any) {
            return PortfolioApiFp(configuration).unsharePortfolio(portfolioId, unsharePolicy, options)(axios, basePath);
        },
        /**
         * Returns the edited portfolio.
         * @summary Edit an existing portfolio
         * @param {string} id ID of the resource
         * @param {Portfolio} portfolio Parameters needed to update a Portfolio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolio(id: string, portfolio: Portfolio, options?: any) {
            return PortfolioApiFp(configuration).updatePortfolio(id, portfolio, options)(axios, basePath);
        },
    };
};

/**
 * PortfolioApi - object-oriented interface
 * @export
 * @class PortfolioApi
 * @extends {BaseAPI}
 */
export class PortfolioApi extends BaseAPI {
    /**
     * Adds a new portfolio item to an existing portfolio.
     * @summary Add a portfolio item to a portfolio
     * @param {string} portfolioId The Portfolio ID
     * @param {AddPortfolioItem} addPortfolioItem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public addPortfolioItemToPortfolio(portfolioId: string, addPortfolioItem: AddPortfolioItem, options?: any) {
        return PortfolioApiFp(this.configuration).addPortfolioItemToPortfolio(portfolioId, addPortfolioItem, options)(this.axios, this.basePath);
    }

    /**
     * Adds a portfolio.
     * @summary Add a new portfolio
     * @param {Portfolio} portfolio Parameters needed to add a Portfolio
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public createPortfolio(portfolio: Portfolio, options?: any) {
        return PortfolioApiFp(this.configuration).createPortfolio(portfolio, options)(this.axios, this.basePath);
    }

    /**
     * Deletes the portfolio specified by the ID.
     * @summary Delete an existing portfolio
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public destroyPortfolio(id: string, options?: any) {
        return PortfolioApiFp(this.configuration).destroyPortfolio(id, options)(this.axios, this.basePath);
    }

    /**
     * Gets all portfilio items in the portfolio specified by the given ID.
     * @summary Get all portfolio items from a specific portfolio
     * @param {string} portfolioId The Portfolio ID
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public fetchPortfolioItemsWithPortfolio(portfolioId: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return PortfolioApiFp(this.configuration).fetchPortfolioItemsWithPortfolio(portfolioId, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Gets a list of portfolios.
     * @summary List portfolios
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public listPortfolios(limit?: number, offset?: number, filter?: any, options?: any) {
        return PortfolioApiFp(this.configuration).listPortfolios(limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Make a copy of the Portfolio.
     * @summary Make a copy of the Portfolio
     * @param {string} portfolioId The Portfolio ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public postCopyPortfolio(portfolioId: string, options?: any) {
        return PortfolioApiFp(this.configuration).postCopyPortfolio(portfolioId, options)(this.axios, this.basePath);
    }

    /**
     * Fetch share information about a portfolio
     * @summary Fetch share information about this portfolio, the response would include a collection of groups and permissions with each group
     * @param {string} portfolioId The Portfolio ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public shareInfo(portfolioId: string, options?: any) {
        return PortfolioApiFp(this.configuration).shareInfo(portfolioId, options)(this.axios, this.basePath);
    }

    /**
     * Share a Portfolio with one or more groups with specific permissions
     * @summary Share a portfolio with one or more groups with specific permission
     * @param {string} portfolioId The Portfolio ID
     * @param {SharePolicy} sharePolicy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public sharePortfolio(portfolioId: string, sharePolicy: SharePolicy, options?: any) {
        return PortfolioApiFp(this.configuration).sharePortfolio(portfolioId, sharePolicy, options)(this.axios, this.basePath);
    }

    /**
     * Gets the portfolio specified by the portfolio ID.
     * @summary Get a specific portfolio
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public showPortfolio(id: string, options?: any) {
        return PortfolioApiFp(this.configuration).showPortfolio(id, options)(this.axios, this.basePath);
    }

    /**
     * Undeletes the portfolio specified by the portfolio ID.
     * @summary Undelete specific portfolio
     * @param {string} id ID of the resource
     * @param {RestoreKey} restoreKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public unDeletePortfolio(id: string, restoreKey: RestoreKey, options?: any) {
        return PortfolioApiFp(this.configuration).unDeletePortfolio(id, restoreKey, options)(this.axios, this.basePath);
    }

    /**
     * Unshare a Portfolio with one or more groups with specific permissions
     * @summary Unshare a portfolio from one or more groups with specific permission
     * @param {string} portfolioId The Portfolio ID
     * @param {UnsharePolicy} unsharePolicy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public unsharePortfolio(portfolioId: string, unsharePolicy: UnsharePolicy, options?: any) {
        return PortfolioApiFp(this.configuration).unsharePortfolio(portfolioId, unsharePolicy, options)(this.axios, this.basePath);
    }

    /**
     * Returns the edited portfolio.
     * @summary Edit an existing portfolio
     * @param {string} id ID of the resource
     * @param {Portfolio} portfolio Parameters needed to update a Portfolio
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public updatePortfolio(id: string, portfolio: Portfolio, options?: any) {
        return PortfolioApiFp(this.configuration).updatePortfolio(id, portfolio, options)(this.axios, this.basePath);
    }

}

/**
 * PortfolioItemApi - axios parameter creator
 * @export
 */
export const PortfolioItemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a name and description for a portfolio item and returns the newly created portfolio item.
         * @summary Add a new portfolio item
         * @param {CreatePortfolioItem} createPortfolioItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPortfolioItem(createPortfolioItem: CreatePortfolioItem, options: any = {}): RequestArgs {
            // verify required parameter 'createPortfolioItem' is not null or undefined
            if (createPortfolioItem === null || createPortfolioItem === undefined) {
                throw new RequiredError('createPortfolioItem','Required parameter createPortfolioItem was null or undefined when calling createPortfolioItem.');
            }
            const localVarPath = `/portfolio_items`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreatePortfolioItem" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createPortfolioItem || {}) : (createPortfolioItem || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the portfolio item based on portfolio item ID passed
         * @summary Delete an existing portfolio item
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyPortfolioItem(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling destroyPortfolioItem.');
            }
            const localVarPath = `/portfolio_items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of portfolio items.
         * @summary List all portfolio items
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPortfolioItems(limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            const localVarPath = `/portfolio_items`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the provider control parameters for a portfolio item.
         * @summary Gets the provider control parameters for this portfolio item; requires control paramaters provided when provisioning the portfolio item.
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProviderControlParameters(portfolioItemId: string, options: any = {}): RequestArgs {
            // verify required parameter 'portfolioItemId' is not null or undefined
            if (portfolioItemId === null || portfolioItemId === undefined) {
                throw new RequiredError('portfolioItemId','Required parameter portfolioItemId was null or undefined when calling listProviderControlParameters.');
            }
            const localVarPath = `/portfolio_items/{portfolio_item_id}/provider_control_parameters`
                .replace(`{${"portfolio_item_id"}}`, encodeURIComponent(String(portfolioItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the specified portfolio item's icon information.
         * @summary Fetches the specified portfolio item's icon information
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceOfferingIcon(portfolioItemId: string, options: any = {}): RequestArgs {
            // verify required parameter 'portfolioItemId' is not null or undefined
            if (portfolioItemId === null || portfolioItemId === undefined) {
                throw new RequiredError('portfolioItemId','Required parameter portfolioItemId was null or undefined when calling listServiceOfferingIcon.');
            }
            const localVarPath = `/portfolio_items/{portfolio_item_id}/icon`
                .replace(`{${"portfolio_item_id"}}`, encodeURIComponent(String(portfolioItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets all service plans for a portfolio item.
         * @summary Gets all service plans for a specific portfolio item; requires a connection to the topology service.
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServicePlans(portfolioItemId: string, options: any = {}): RequestArgs {
            // verify required parameter 'portfolioItemId' is not null or undefined
            if (portfolioItemId === null || portfolioItemId === undefined) {
                throw new RequiredError('portfolioItemId','Required parameter portfolioItemId was null or undefined when calling listServicePlans.');
            }
            const localVarPath = `/portfolio_items/{portfolio_item_id}/service_plans`
                .replace(`{${"portfolio_item_id"}}`, encodeURIComponent(String(portfolioItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If a record has been discarded, this operation will undelete it so it can be requested normally.
         * @summary Undelete a specified Portfolio Item
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {RestoreKey} restoreKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioItemsPortfolioItemIdUndeletePost(portfolioItemId: string, restoreKey: RestoreKey, options: any = {}): RequestArgs {
            // verify required parameter 'portfolioItemId' is not null or undefined
            if (portfolioItemId === null || portfolioItemId === undefined) {
                throw new RequiredError('portfolioItemId','Required parameter portfolioItemId was null or undefined when calling portfolioItemsPortfolioItemIdUndeletePost.');
            }
            // verify required parameter 'restoreKey' is not null or undefined
            if (restoreKey === null || restoreKey === undefined) {
                throw new RequiredError('restoreKey','Required parameter restoreKey was null or undefined when calling portfolioItemsPortfolioItemIdUndeletePost.');
            }
            const localVarPath = `/portfolio_items/{portfolio_item_id}/undelete`
                .replace(`{${"portfolio_item_id"}}`, encodeURIComponent(String(portfolioItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RestoreKey" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(restoreKey || {}) : (restoreKey || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Make a copy of the Portfolio Item.
         * @summary Make a copy of the Portfolio Item
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {CopyPortfolioItem} [copyPortfolioItem]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCopyPortfolioItem(portfolioItemId: string, copyPortfolioItem?: CopyPortfolioItem, options: any = {}): RequestArgs {
            // verify required parameter 'portfolioItemId' is not null or undefined
            if (portfolioItemId === null || portfolioItemId === undefined) {
                throw new RequiredError('portfolioItemId','Required parameter portfolioItemId was null or undefined when calling postCopyPortfolioItem.');
            }
            const localVarPath = `/portfolio_items/{portfolio_item_id}/copy`
                .replace(`{${"portfolio_item_id"}}`, encodeURIComponent(String(portfolioItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CopyPortfolioItem" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(copyPortfolioItem || {}) : (copyPortfolioItem || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific portfolio item based on the portfolio item ID passed
         * @summary Gets a specific portfolio item
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showPortfolioItem(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showPortfolioItem.');
            }
            const localVarPath = `/portfolio_items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edits portfolio item specified by the given ID.
         * @summary Edit an existing portfolio item
         * @param {string} id ID of the resource
         * @param {PortfolioItem} portfolioItem Parameters needed to update a Portfolio Item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolioItem(id: string, portfolioItem: PortfolioItem, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updatePortfolioItem.');
            }
            // verify required parameter 'portfolioItem' is not null or undefined
            if (portfolioItem === null || portfolioItem === undefined) {
                throw new RequiredError('portfolioItem','Required parameter portfolioItem was null or undefined when calling updatePortfolioItem.');
            }
            const localVarPath = `/portfolio_items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PortfolioItem" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(portfolioItem || {}) : (portfolioItem || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PortfolioItemApi - functional programming interface
 * @export
 */
export const PortfolioItemApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds a name and description for a portfolio item and returns the newly created portfolio item.
         * @summary Add a new portfolio item
         * @param {CreatePortfolioItem} createPortfolioItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPortfolioItem(createPortfolioItem: CreatePortfolioItem, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioItem> {
            const localVarAxiosArgs = PortfolioItemApiAxiosParamCreator(configuration).createPortfolioItem(createPortfolioItem, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes the portfolio item based on portfolio item ID passed
         * @summary Delete an existing portfolio item
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyPortfolioItem(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestoreKey> {
            const localVarAxiosArgs = PortfolioItemApiAxiosParamCreator(configuration).destroyPortfolioItem(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a list of portfolio items.
         * @summary List all portfolio items
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPortfolioItems(limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioItemsCollection> {
            const localVarAxiosArgs = PortfolioItemApiAxiosParamCreator(configuration).listPortfolioItems(limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets the provider control parameters for a portfolio item.
         * @summary Gets the provider control parameters for this portfolio item; requires control paramaters provided when provisioning the portfolio item.
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProviderControlParameters(portfolioItemId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = PortfolioItemApiAxiosParamCreator(configuration).listProviderControlParameters(portfolioItemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch the specified portfolio item's icon information.
         * @summary Fetches the specified portfolio item's icon information
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceOfferingIcon(portfolioItemId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceOfferingIcon> {
            const localVarAxiosArgs = PortfolioItemApiAxiosParamCreator(configuration).listServiceOfferingIcon(portfolioItemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets all service plans for a portfolio item.
         * @summary Gets all service plans for a specific portfolio item; requires a connection to the topology service.
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServicePlans(portfolioItemId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServicePlan>> {
            const localVarAxiosArgs = PortfolioItemApiAxiosParamCreator(configuration).listServicePlans(portfolioItemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * If a record has been discarded, this operation will undelete it so it can be requested normally.
         * @summary Undelete a specified Portfolio Item
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {RestoreKey} restoreKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioItemsPortfolioItemIdUndeletePost(portfolioItemId: string, restoreKey: RestoreKey, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioItem> {
            const localVarAxiosArgs = PortfolioItemApiAxiosParamCreator(configuration).portfolioItemsPortfolioItemIdUndeletePost(portfolioItemId, restoreKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Make a copy of the Portfolio Item.
         * @summary Make a copy of the Portfolio Item
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {CopyPortfolioItem} [copyPortfolioItem]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCopyPortfolioItem(portfolioItemId: string, copyPortfolioItem?: CopyPortfolioItem, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioItem> {
            const localVarAxiosArgs = PortfolioItemApiAxiosParamCreator(configuration).postCopyPortfolioItem(portfolioItemId, copyPortfolioItem, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a specific portfolio item based on the portfolio item ID passed
         * @summary Gets a specific portfolio item
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showPortfolioItem(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioItem> {
            const localVarAxiosArgs = PortfolioItemApiAxiosParamCreator(configuration).showPortfolioItem(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Edits portfolio item specified by the given ID.
         * @summary Edit an existing portfolio item
         * @param {string} id ID of the resource
         * @param {PortfolioItem} portfolioItem Parameters needed to update a Portfolio Item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolioItem(id: string, portfolioItem: PortfolioItem, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioItem> {
            const localVarAxiosArgs = PortfolioItemApiAxiosParamCreator(configuration).updatePortfolioItem(id, portfolioItem, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PortfolioItemApi - factory interface
 * @export
 */
export const PortfolioItemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Adds a name and description for a portfolio item and returns the newly created portfolio item.
         * @summary Add a new portfolio item
         * @param {CreatePortfolioItem} createPortfolioItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPortfolioItem(createPortfolioItem: CreatePortfolioItem, options?: any) {
            return PortfolioItemApiFp(configuration).createPortfolioItem(createPortfolioItem, options)(axios, basePath);
        },
        /**
         * Deletes the portfolio item based on portfolio item ID passed
         * @summary Delete an existing portfolio item
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyPortfolioItem(id: string, options?: any) {
            return PortfolioItemApiFp(configuration).destroyPortfolioItem(id, options)(axios, basePath);
        },
        /**
         * Gets a list of portfolio items.
         * @summary List all portfolio items
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPortfolioItems(limit?: number, offset?: number, filter?: any, options?: any) {
            return PortfolioItemApiFp(configuration).listPortfolioItems(limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Gets the provider control parameters for a portfolio item.
         * @summary Gets the provider control parameters for this portfolio item; requires control paramaters provided when provisioning the portfolio item.
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProviderControlParameters(portfolioItemId: string, options?: any) {
            return PortfolioItemApiFp(configuration).listProviderControlParameters(portfolioItemId, options)(axios, basePath);
        },
        /**
         * Fetch the specified portfolio item's icon information.
         * @summary Fetches the specified portfolio item's icon information
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceOfferingIcon(portfolioItemId: string, options?: any) {
            return PortfolioItemApiFp(configuration).listServiceOfferingIcon(portfolioItemId, options)(axios, basePath);
        },
        /**
         * Gets all service plans for a portfolio item.
         * @summary Gets all service plans for a specific portfolio item; requires a connection to the topology service.
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServicePlans(portfolioItemId: string, options?: any) {
            return PortfolioItemApiFp(configuration).listServicePlans(portfolioItemId, options)(axios, basePath);
        },
        /**
         * If a record has been discarded, this operation will undelete it so it can be requested normally.
         * @summary Undelete a specified Portfolio Item
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {RestoreKey} restoreKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioItemsPortfolioItemIdUndeletePost(portfolioItemId: string, restoreKey: RestoreKey, options?: any) {
            return PortfolioItemApiFp(configuration).portfolioItemsPortfolioItemIdUndeletePost(portfolioItemId, restoreKey, options)(axios, basePath);
        },
        /**
         * Make a copy of the Portfolio Item.
         * @summary Make a copy of the Portfolio Item
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {CopyPortfolioItem} [copyPortfolioItem]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCopyPortfolioItem(portfolioItemId: string, copyPortfolioItem?: CopyPortfolioItem, options?: any) {
            return PortfolioItemApiFp(configuration).postCopyPortfolioItem(portfolioItemId, copyPortfolioItem, options)(axios, basePath);
        },
        /**
         * Gets a specific portfolio item based on the portfolio item ID passed
         * @summary Gets a specific portfolio item
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showPortfolioItem(id: string, options?: any) {
            return PortfolioItemApiFp(configuration).showPortfolioItem(id, options)(axios, basePath);
        },
        /**
         * Edits portfolio item specified by the given ID.
         * @summary Edit an existing portfolio item
         * @param {string} id ID of the resource
         * @param {PortfolioItem} portfolioItem Parameters needed to update a Portfolio Item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolioItem(id: string, portfolioItem: PortfolioItem, options?: any) {
            return PortfolioItemApiFp(configuration).updatePortfolioItem(id, portfolioItem, options)(axios, basePath);
        },
    };
};

/**
 * PortfolioItemApi - object-oriented interface
 * @export
 * @class PortfolioItemApi
 * @extends {BaseAPI}
 */
export class PortfolioItemApi extends BaseAPI {
    /**
     * Adds a name and description for a portfolio item and returns the newly created portfolio item.
     * @summary Add a new portfolio item
     * @param {CreatePortfolioItem} createPortfolioItem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioItemApi
     */
    public createPortfolioItem(createPortfolioItem: CreatePortfolioItem, options?: any) {
        return PortfolioItemApiFp(this.configuration).createPortfolioItem(createPortfolioItem, options)(this.axios, this.basePath);
    }

    /**
     * Deletes the portfolio item based on portfolio item ID passed
     * @summary Delete an existing portfolio item
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioItemApi
     */
    public destroyPortfolioItem(id: string, options?: any) {
        return PortfolioItemApiFp(this.configuration).destroyPortfolioItem(id, options)(this.axios, this.basePath);
    }

    /**
     * Gets a list of portfolio items.
     * @summary List all portfolio items
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioItemApi
     */
    public listPortfolioItems(limit?: number, offset?: number, filter?: any, options?: any) {
        return PortfolioItemApiFp(this.configuration).listPortfolioItems(limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Gets the provider control parameters for a portfolio item.
     * @summary Gets the provider control parameters for this portfolio item; requires control paramaters provided when provisioning the portfolio item.
     * @param {string} portfolioItemId The Portfolio Item ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioItemApi
     */
    public listProviderControlParameters(portfolioItemId: string, options?: any) {
        return PortfolioItemApiFp(this.configuration).listProviderControlParameters(portfolioItemId, options)(this.axios, this.basePath);
    }

    /**
     * Fetch the specified portfolio item's icon information.
     * @summary Fetches the specified portfolio item's icon information
     * @param {string} portfolioItemId The Portfolio Item ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioItemApi
     */
    public listServiceOfferingIcon(portfolioItemId: string, options?: any) {
        return PortfolioItemApiFp(this.configuration).listServiceOfferingIcon(portfolioItemId, options)(this.axios, this.basePath);
    }

    /**
     * Gets all service plans for a portfolio item.
     * @summary Gets all service plans for a specific portfolio item; requires a connection to the topology service.
     * @param {string} portfolioItemId The Portfolio Item ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioItemApi
     */
    public listServicePlans(portfolioItemId: string, options?: any) {
        return PortfolioItemApiFp(this.configuration).listServicePlans(portfolioItemId, options)(this.axios, this.basePath);
    }

    /**
     * If a record has been discarded, this operation will undelete it so it can be requested normally.
     * @summary Undelete a specified Portfolio Item
     * @param {string} portfolioItemId The Portfolio Item ID
     * @param {RestoreKey} restoreKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioItemApi
     */
    public portfolioItemsPortfolioItemIdUndeletePost(portfolioItemId: string, restoreKey: RestoreKey, options?: any) {
        return PortfolioItemApiFp(this.configuration).portfolioItemsPortfolioItemIdUndeletePost(portfolioItemId, restoreKey, options)(this.axios, this.basePath);
    }

    /**
     * Make a copy of the Portfolio Item.
     * @summary Make a copy of the Portfolio Item
     * @param {string} portfolioItemId The Portfolio Item ID
     * @param {CopyPortfolioItem} [copyPortfolioItem]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioItemApi
     */
    public postCopyPortfolioItem(portfolioItemId: string, copyPortfolioItem?: CopyPortfolioItem, options?: any) {
        return PortfolioItemApiFp(this.configuration).postCopyPortfolioItem(portfolioItemId, copyPortfolioItem, options)(this.axios, this.basePath);
    }

    /**
     * Gets a specific portfolio item based on the portfolio item ID passed
     * @summary Gets a specific portfolio item
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioItemApi
     */
    public showPortfolioItem(id: string, options?: any) {
        return PortfolioItemApiFp(this.configuration).showPortfolioItem(id, options)(this.axios, this.basePath);
    }

    /**
     * Edits portfolio item specified by the given ID.
     * @summary Edit an existing portfolio item
     * @param {string} id ID of the resource
     * @param {PortfolioItem} portfolioItem Parameters needed to update a Portfolio Item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioItemApi
     */
    public updatePortfolioItem(id: string, portfolioItem: PortfolioItem, options?: any) {
        return PortfolioItemApiFp(this.configuration).updatePortfolioItem(id, portfolioItem, options)(this.axios, this.basePath);
    }

}

