// tslint:disable
/// <reference path="./custom.d.ts" />
/**
 * Insights Service Approval APIs
 * APIs to query approval service
 *
 * OpenAPI spec version: 1.0.0
 * Contact: support@redhat.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';

const BASE_PATH = "https://cloud.redhat.com//api/approval/v1.0".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface RequestArgs
 */
export interface RequestArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration | undefined;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected axios: AxiosInstance = globalAxios) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * Input parameters for Action object
 * @export
 * @interface ActionIn
 */
export interface ActionIn {
    /**
     * The person who performs the action
     * @type {string}
     * @memberof ActionIn
     */
    processedBy?: string;
    /**
     * Types of action, may be one of the value (approve, deny, notify, memo, or skip). The stage will be updated according to the operation.
     * @type {string}
     * @memberof ActionIn
     */
    operation: ActionIn.OperationEnum;
    /**
     * Comments for action
     * @type {string}
     * @memberof ActionIn
     */
    comments?: string;
}

/**
 * @export
 * @namespace ActionIn
 */
export namespace ActionIn {
    /**
     * @export
     * @enum {string}
     */
    export enum OperationEnum {
        Approve = 'approve',
        Deny = 'deny',
        Notify = 'notify',
        Memo = 'memo',
        Skip = 'skip'
    }
}

/**
 *
 * @export
 * @interface ActionOut
 */
export interface ActionOut {
    /**
     *
     * @type {string}
     * @memberof ActionOut
     */
    id: string;
    /**
     * Timestamp of creation
     * @type {Date}
     * @memberof ActionOut
     */
    createdAt?: Date;
    /**
     * Associated stage id
     * @type {string}
     * @memberof ActionOut
     */
    stageId: string;
    /**
     * The person who performs the action
     * @type {string}
     * @memberof ActionOut
     */
    processedBy?: string;
    /**
     * Types of action, may be one of the value (approve, deny, notify, memo, or skip). The stage will be updated according to the operation.
     * @type {string}
     * @memberof ActionOut
     */
    operation?: ActionOut.OperationEnum;
    /**
     * Comments for action
     * @type {string}
     * @memberof ActionOut
     */
    comments?: string;
}

/**
 * @export
 * @namespace ActionOut
 */
export namespace ActionOut {
    /**
     * @export
     * @enum {string}
     */
    export enum OperationEnum {
        Approve = 'approve',
        Deny = 'deny',
        Notify = 'notify',
        Memo = 'memo',
        Skip = 'skip'
    }
}

/**
 *
 * @export
 * @interface ActionOutCollection
 */
export interface ActionOutCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof ActionOutCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof ActionOutCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<ActionOut>}
     * @memberof ActionOutCollection
     */
    data?: Array<ActionOut>;
}

/**
 *
 * @export
 * @interface CollectionLinks
 */
export interface CollectionLinks {
    /**
     * The link to fetch the first group of items in the result set
     * @type {string}
     * @memberof CollectionLinks
     */
    first?: string;
    /**
     * The link to fetch the last group of items in the result set
     * @type {string}
     * @memberof CollectionLinks
     */
    last?: string;
    /**
     * The link to fetch the previous group of items in the result set
     * @type {string}
     * @memberof CollectionLinks
     */
    prev?: string;
    /**
     * The link to fetch the next group of items in the result set
     * @type {string}
     * @memberof CollectionLinks
     */
    next?: string;
}

/**
 *
 * @export
 * @interface CollectionMetadata
 */
export interface CollectionMetadata {
    /**
     * This is the total number of items in the result set, of which only a subset is returned defined by the QueryLimit parameter
     * @type {number}
     * @memberof CollectionMetadata
     */
    count?: number;
}

/**
 * Input parameters for approval request object.
 * @export
 * @interface RequestIn
 */
export interface RequestIn {
    /**
     * Requester id
     * @type {string}
     * @memberof RequestIn
     */
    requester?: string;
    /**
     * Request name
     * @type {string}
     * @memberof RequestIn
     */
    name: string;
    /**
     * Request description
     * @type {string}
     * @memberof RequestIn
     */
    description?: string;
    /**
     * JSON object with request content
     * @type {any}
     * @memberof RequestIn
     */
    content: any;
}

/**
 * Approval request. Each request will associate with a workflow. Corresponding to the groups of the associated workflow, every request will have a list of stages to record the request processing details.
 * @export
 * @interface RequestOut
 */
export interface RequestOut {
    /**
     *
     * @type {string}
     * @memberof RequestOut
     */
    id?: string;
    /**
     * The state of stage or request. It may be one of values (pending, skipped, notified or finished)
     * @type {string}
     * @memberof RequestOut
     */
    state?: RequestOut.StateEnum;
    /**
     * Final decision, may be one of the value (undecided, approved, or denied)
     * @type {string}
     * @memberof RequestOut
     */
    decision?: RequestOut.DecisionEnum;
    /**
     * Comments for requests
     * @type {string}
     * @memberof RequestOut
     */
    reason?: string;
    /**
     * Associate workflow id
     * @type {string}
     * @memberof RequestOut
     */
    workflowId?: string;
    /**
     * Timestamp of creation
     * @type {Date}
     * @memberof RequestOut
     */
    createdAt?: Date;
    /**
     * Timestamp of last update
     * @type {Date}
     * @memberof RequestOut
     */
    updatedAt?: Date;
    /**
     * Current (or last) active stage. For regular approver this number is always 0
     * @type {number}
     * @memberof RequestOut
     */
    activeStage?: number;
    /**
     * Total number of stages. For regular approver this number is always 0.
     * @type {number}
     * @memberof RequestOut
     */
    totalStages?: number;
    /**
     * Requester id
     * @type {string}
     * @memberof RequestOut
     */
    requester?: string;
    /**
     * Request name
     * @type {string}
     * @memberof RequestOut
     */
    name?: string;
    /**
     * Request description
     * @type {string}
     * @memberof RequestOut
     */
    description?: string;
    /**
     * JSON object with request content
     * @type {any}
     * @memberof RequestOut
     */
    content?: any;
}

/**
 * @export
 * @namespace RequestOut
 */
export namespace RequestOut {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        Pending = 'pending',
        Skipped = 'skipped',
        Notified = 'notified',
        Finished = 'finished'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum DecisionEnum {
        Undecided = 'undecided',
        Approved = 'approved',
        Denied = 'denied'
    }
}

/**
 *
 * @export
 * @interface RequestOutCollection
 */
export interface RequestOutCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof RequestOutCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof RequestOutCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<RequestOut>}
     * @memberof RequestOutCollection
     */
    data?: Array<RequestOut>;
}

/**
 * A stage of an approval request.
 * @export
 * @interface StageOut
 */
export interface StageOut {
    /**
     *
     * @type {string}
     * @memberof StageOut
     */
    id?: string;
    /**
     * name of the group that processes the stage
     * @type {string}
     * @memberof StageOut
     */
    name?: string;
    /**
     * Associated group reference id
     * @type {string}
     * @memberof StageOut
     */
    groupRef?: string;
    /**
     * The state of stage or request. It may be one of values (pending, skipped, notified or finished)
     * @type {string}
     * @memberof StageOut
     */
    state?: StageOut.StateEnum;
    /**
     * Final decision, may be one of the value (undecided, approved, or denied)
     * @type {string}
     * @memberof StageOut
     */
    decision?: StageOut.DecisionEnum;
    /**
     * the time approvers in the stage are notified
     * @type {string}
     * @memberof StageOut
     */
    notifiedAt?: string;
}

/**
 * @export
 * @namespace StageOut
 */
export namespace StageOut {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        Pending = 'pending',
        Skipped = 'skipped',
        Notified = 'notified',
        Finished = 'finished'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum DecisionEnum {
        Undecided = 'undecided',
        Approved = 'approved',
        Denied = 'denied'
    }
}

/**
 *
 * @export
 * @interface StageOutCollection
 */
export interface StageOutCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof StageOutCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof StageOutCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<StageOut>}
     * @memberof StageOutCollection
     */
    data?: Array<StageOut>;
}

/**
 * The template to categorize workflows.
 * @export
 * @interface TemplateOut
 */
export interface TemplateOut {
    /**
     *
     * @type {string}
     * @memberof TemplateOut
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof TemplateOut
     */
    title?: string;
    /**
     *
     * @type {string}
     * @memberof TemplateOut
     */
    description?: string;
}

/**
 *
 * @export
 * @interface TemplateOutCollection
 */
export interface TemplateOutCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof TemplateOutCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof TemplateOutCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<TemplateOut>}
     * @memberof TemplateOutCollection
     */
    data?: Array<TemplateOut>;
}

/**
 *
 * @export
 * @interface WorkflowIn
 */
export interface WorkflowIn {
    /**
     *
     * @type {string}
     * @memberof WorkflowIn
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof WorkflowIn
     */
    description?: string;
    /**
     * Group reference ids associated with workflow
     * @type {Array<string>}
     * @memberof WorkflowIn
     */
    groupRefs: Array<string>;
}

/**
 * The workflow to process approval requests. Each workflow is linked to multiple groups of approvals.
 * @export
 * @interface WorkflowOut
 */
export interface WorkflowOut {
    /**
     *
     * @type {string}
     * @memberof WorkflowOut
     */
    id?: string;
    /**
     * Associated template id
     * @type {string}
     * @memberof WorkflowOut
     */
    templateId?: string;
    /**
     *
     * @type {string}
     * @memberof WorkflowOut
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof WorkflowOut
     */
    description?: string;
    /**
     * Group reference ids associated with workflow
     * @type {Array<string>}
     * @memberof WorkflowOut
     */
    groupRefs?: Array<string>;
}

/**
 *
 * @export
 * @interface WorkflowOutCollection
 */
export interface WorkflowOutCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof WorkflowOutCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof WorkflowOutCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<WorkflowOut>}
     * @memberof WorkflowOutCollection
     */
    data?: Array<WorkflowOut>;
}


/**
 * ActionApi - axios parameter creator
 * @export
 */
export const ActionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add an action to a given stage
         * @summary Add an action to a given stage
         * @param {string} stageId Id of stage
         * @param {ActionIn} actionIn Action object that will be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAction(stageId: string, actionIn: ActionIn, options: any = {}): RequestArgs {
            // verify required parameter 'stageId' is not null or undefined
            if (stageId === null || stageId === undefined) {
                throw new RequiredError('stageId','Required parameter stageId was null or undefined when calling createAction.');
            }
            // verify required parameter 'actionIn' is not null or undefined
            if (actionIn === null || actionIn === undefined) {
                throw new RequiredError('actionIn','Required parameter actionIn was null or undefined when calling createAction.');
            }
            const localVarPath = `/stages/{stage_id}/actions`
                .replace(`{${"stage_id"}}`, encodeURIComponent(String(stageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ActionIn" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(actionIn || {}) : (actionIn || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add an action to current active stage of a given request. If request is finished, i.e. no current active stage is available, no action can be posted here.
         * @summary Add an action to current active stage of a given request
         * @param {string} requestId Id of request
         * @param {ActionIn} actionIn Action object that will be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionByRequest(requestId: string, actionIn: ActionIn, options: any = {}): RequestArgs {
            // verify required parameter 'requestId' is not null or undefined
            if (requestId === null || requestId === undefined) {
                throw new RequiredError('requestId','Required parameter requestId was null or undefined when calling createActionByRequest.');
            }
            // verify required parameter 'actionIn' is not null or undefined
            if (actionIn === null || actionIn === undefined) {
                throw new RequiredError('actionIn','Required parameter actionIn was null or undefined when calling createActionByRequest.');
            }
            const localVarPath = `/requests/{request_id}/actions`
                .replace(`{${"request_id"}}`, encodeURIComponent(String(requestId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ActionIn" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(actionIn || {}) : (actionIn || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all actions of a stage
         * @summary Return actions in a given stage
         * @param {string} stageId Id of stage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsByStage(stageId: string, options: any = {}): RequestArgs {
            // verify required parameter 'stageId' is not null or undefined
            if (stageId === null || stageId === undefined) {
                throw new RequiredError('stageId','Required parameter stageId was null or undefined when calling listActionsByStage.');
            }
            const localVarPath = `/stages/{stage_id}/actions`
                .replace(`{${"stage_id"}}`, encodeURIComponent(String(stageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return an user action by id
         * @summary Return an user action by id
         * @param {string} id Query by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showAction(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showAction.');
            }
            const localVarPath = `/actions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActionApi - functional programming interface
 * @export
 */
export const ActionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Add an action to a given stage
         * @summary Add an action to a given stage
         * @param {string} stageId Id of stage
         * @param {ActionIn} actionIn Action object that will be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAction(stageId: string, actionIn: ActionIn, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionOut> {
            const localVarAxiosArgs = ActionApiAxiosParamCreator(configuration).createAction(stageId, actionIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Add an action to current active stage of a given request. If request is finished, i.e. no current active stage is available, no action can be posted here.
         * @summary Add an action to current active stage of a given request
         * @param {string} requestId Id of request
         * @param {ActionIn} actionIn Action object that will be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionByRequest(requestId: string, actionIn: ActionIn, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionOut> {
            const localVarAxiosArgs = ActionApiAxiosParamCreator(configuration).createActionByRequest(requestId, actionIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List all actions of a stage
         * @summary Return actions in a given stage
         * @param {string} stageId Id of stage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsByStage(stageId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionOutCollection> {
            const localVarAxiosArgs = ActionApiAxiosParamCreator(configuration).listActionsByStage(stageId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Return an user action by id
         * @summary Return an user action by id
         * @param {string} id Query by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showAction(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionOut> {
            const localVarAxiosArgs = ActionApiAxiosParamCreator(configuration).showAction(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ActionApi - factory interface
 * @export
 */
export const ActionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Add an action to a given stage
         * @summary Add an action to a given stage
         * @param {string} stageId Id of stage
         * @param {ActionIn} actionIn Action object that will be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAction(stageId: string, actionIn: ActionIn, options?: any) {
            return ActionApiFp(configuration).createAction(stageId, actionIn, options)(axios, basePath);
        },
        /**
         * Add an action to current active stage of a given request. If request is finished, i.e. no current active stage is available, no action can be posted here.
         * @summary Add an action to current active stage of a given request
         * @param {string} requestId Id of request
         * @param {ActionIn} actionIn Action object that will be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionByRequest(requestId: string, actionIn: ActionIn, options?: any) {
            return ActionApiFp(configuration).createActionByRequest(requestId, actionIn, options)(axios, basePath);
        },
        /**
         * List all actions of a stage
         * @summary Return actions in a given stage
         * @param {string} stageId Id of stage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsByStage(stageId: string, options?: any) {
            return ActionApiFp(configuration).listActionsByStage(stageId, options)(axios, basePath);
        },
        /**
         * Return an user action by id
         * @summary Return an user action by id
         * @param {string} id Query by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showAction(id: string, options?: any) {
            return ActionApiFp(configuration).showAction(id, options)(axios, basePath);
        },
    };
};

/**
 * ActionApi - object-oriented interface
 * @export
 * @class ActionApi
 * @extends {BaseAPI}
 */
export class ActionApi extends BaseAPI {
    /**
     * Add an action to a given stage
     * @summary Add an action to a given stage
     * @param {string} stageId Id of stage
     * @param {ActionIn} actionIn Action object that will be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public createAction(stageId: string, actionIn: ActionIn, options?: any) {
        return ActionApiFp(this.configuration).createAction(stageId, actionIn, options)(this.axios, this.basePath);
    }

    /**
     * Add an action to current active stage of a given request. If request is finished, i.e. no current active stage is available, no action can be posted here.
     * @summary Add an action to current active stage of a given request
     * @param {string} requestId Id of request
     * @param {ActionIn} actionIn Action object that will be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public createActionByRequest(requestId: string, actionIn: ActionIn, options?: any) {
        return ActionApiFp(this.configuration).createActionByRequest(requestId, actionIn, options)(this.axios, this.basePath);
    }

    /**
     * List all actions of a stage
     * @summary Return actions in a given stage
     * @param {string} stageId Id of stage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public listActionsByStage(stageId: string, options?: any) {
        return ActionApiFp(this.configuration).listActionsByStage(stageId, options)(this.axios, this.basePath);
    }

    /**
     * Return an user action by id
     * @summary Return an user action by id
     * @param {string} id Query by id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public showAction(id: string, options?: any) {
        return ActionApiFp(this.configuration).showAction(id, options)(this.axios, this.basePath);
    }

}

/**
 * RequestApi - axios parameter creator
 * @export
 */
export const RequestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add an approval request by given parameters
         * @summary Add an approval request by given parameters
         * @param {string} workflowId Id of workflow
         * @param {RequestIn} requestIn Parameters need to create a request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRequest(workflowId: string, requestIn: RequestIn, options: any = {}): RequestArgs {
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new RequiredError('workflowId','Required parameter workflowId was null or undefined when calling createRequest.');
            }
            // verify required parameter 'requestIn' is not null or undefined
            if (requestIn === null || requestIn === undefined) {
                throw new RequiredError('requestIn','Required parameter requestIn was null or undefined when calling createRequest.');
            }
            const localVarPath = `/workflows/{workflow_id}/requests`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RequestIn" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestIn || {}) : (requestIn || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return an array of requests
         * @summary Return an array of approval requests
         * @param {string} [approver] Fetch requests by given approver username
         * @param {number} [limit] How many items to return at one time (max 1000)
         * @param {number} [offset] Starting Offset
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRequests(approver?: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            const localVarPath = `/requests`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (approver !== undefined) {
                localVarQueryParameter['approver'] = approver;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return approval requests by given workflow id
         * @summary Return approval requests by given workflow id
         * @param {string} workflowId Id of workflow
         * @param {number} [limit] How many items to return at one time (max 1000)
         * @param {number} [offset] Starting Offset
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRequestsByWorkflow(workflowId: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new RequiredError('workflowId','Required parameter workflowId was null or undefined when calling listRequestsByWorkflow.');
            }
            const localVarPath = `/workflows/{workflow_id}/requests`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return an approval request by given id
         * @summary Return an approval request by given id
         * @param {string} id Query by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showRequest(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showRequest.');
            }
            const localVarPath = `/requests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RequestApi - functional programming interface
 * @export
 */
export const RequestApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Add an approval request by given parameters
         * @summary Add an approval request by given parameters
         * @param {string} workflowId Id of workflow
         * @param {RequestIn} requestIn Parameters need to create a request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRequest(workflowId: string, requestIn: RequestIn, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RequestOut> {
            const localVarAxiosArgs = RequestApiAxiosParamCreator(configuration).createRequest(workflowId, requestIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Return an array of requests
         * @summary Return an array of approval requests
         * @param {string} [approver] Fetch requests by given approver username
         * @param {number} [limit] How many items to return at one time (max 1000)
         * @param {number} [offset] Starting Offset
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRequests(approver?: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RequestOutCollection> {
            const localVarAxiosArgs = RequestApiAxiosParamCreator(configuration).listRequests(approver, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Return approval requests by given workflow id
         * @summary Return approval requests by given workflow id
         * @param {string} workflowId Id of workflow
         * @param {number} [limit] How many items to return at one time (max 1000)
         * @param {number} [offset] Starting Offset
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRequestsByWorkflow(workflowId: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RequestOutCollection> {
            const localVarAxiosArgs = RequestApiAxiosParamCreator(configuration).listRequestsByWorkflow(workflowId, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Return an approval request by given id
         * @summary Return an approval request by given id
         * @param {string} id Query by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showRequest(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RequestOut> {
            const localVarAxiosArgs = RequestApiAxiosParamCreator(configuration).showRequest(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RequestApi - factory interface
 * @export
 */
export const RequestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Add an approval request by given parameters
         * @summary Add an approval request by given parameters
         * @param {string} workflowId Id of workflow
         * @param {RequestIn} requestIn Parameters need to create a request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRequest(workflowId: string, requestIn: RequestIn, options?: any) {
            return RequestApiFp(configuration).createRequest(workflowId, requestIn, options)(axios, basePath);
        },
        /**
         * Return an array of requests
         * @summary Return an array of approval requests
         * @param {string} [approver] Fetch requests by given approver username
         * @param {number} [limit] How many items to return at one time (max 1000)
         * @param {number} [offset] Starting Offset
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRequests(approver?: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return RequestApiFp(configuration).listRequests(approver, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Return approval requests by given workflow id
         * @summary Return approval requests by given workflow id
         * @param {string} workflowId Id of workflow
         * @param {number} [limit] How many items to return at one time (max 1000)
         * @param {number} [offset] Starting Offset
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRequestsByWorkflow(workflowId: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return RequestApiFp(configuration).listRequestsByWorkflow(workflowId, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Return an approval request by given id
         * @summary Return an approval request by given id
         * @param {string} id Query by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showRequest(id: string, options?: any) {
            return RequestApiFp(configuration).showRequest(id, options)(axios, basePath);
        },
    };
};

/**
 * RequestApi - object-oriented interface
 * @export
 * @class RequestApi
 * @extends {BaseAPI}
 */
export class RequestApi extends BaseAPI {
    /**
     * Add an approval request by given parameters
     * @summary Add an approval request by given parameters
     * @param {string} workflowId Id of workflow
     * @param {RequestIn} requestIn Parameters need to create a request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestApi
     */
    public createRequest(workflowId: string, requestIn: RequestIn, options?: any) {
        return RequestApiFp(this.configuration).createRequest(workflowId, requestIn, options)(this.axios, this.basePath);
    }

    /**
     * Return an array of requests
     * @summary Return an array of approval requests
     * @param {string} [approver] Fetch requests by given approver username
     * @param {number} [limit] How many items to return at one time (max 1000)
     * @param {number} [offset] Starting Offset
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestApi
     */
    public listRequests(approver?: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return RequestApiFp(this.configuration).listRequests(approver, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Return approval requests by given workflow id
     * @summary Return approval requests by given workflow id
     * @param {string} workflowId Id of workflow
     * @param {number} [limit] How many items to return at one time (max 1000)
     * @param {number} [offset] Starting Offset
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestApi
     */
    public listRequestsByWorkflow(workflowId: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return RequestApiFp(this.configuration).listRequestsByWorkflow(workflowId, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Return an approval request by given id
     * @summary Return an approval request by given id
     * @param {string} id Query by id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestApi
     */
    public showRequest(id: string, options?: any) {
        return RequestApiFp(this.configuration).showRequest(id, options)(this.axios, this.basePath);
    }

}

/**
 * StageApi - axios parameter creator
 * @export
 */
export const StageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return an array of stages by given request id
         * @summary Return an array of stages by given request id
         * @param {string} requestId Id of request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStagesByRequest(requestId: string, options: any = {}): RequestArgs {
            // verify required parameter 'requestId' is not null or undefined
            if (requestId === null || requestId === undefined) {
                throw new RequiredError('requestId','Required parameter requestId was null or undefined when calling listStagesByRequest.');
            }
            const localVarPath = `/requests/{request_id}/stages`
                .replace(`{${"request_id"}}`, encodeURIComponent(String(requestId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return an approval stage by given id
         * @summary Return an approval stage by given id
         * @param {string} id Query by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showStage(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showStage.');
            }
            const localVarPath = `/stages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StageApi - functional programming interface
 * @export
 */
export const StageApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Return an array of stages by given request id
         * @summary Return an array of stages by given request id
         * @param {string} requestId Id of request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStagesByRequest(requestId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StageOutCollection> {
            const localVarAxiosArgs = StageApiAxiosParamCreator(configuration).listStagesByRequest(requestId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Return an approval stage by given id
         * @summary Return an approval stage by given id
         * @param {string} id Query by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showStage(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StageOut> {
            const localVarAxiosArgs = StageApiAxiosParamCreator(configuration).showStage(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * StageApi - factory interface
 * @export
 */
export const StageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Return an array of stages by given request id
         * @summary Return an array of stages by given request id
         * @param {string} requestId Id of request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStagesByRequest(requestId: string, options?: any) {
            return StageApiFp(configuration).listStagesByRequest(requestId, options)(axios, basePath);
        },
        /**
         * Return an approval stage by given id
         * @summary Return an approval stage by given id
         * @param {string} id Query by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showStage(id: string, options?: any) {
            return StageApiFp(configuration).showStage(id, options)(axios, basePath);
        },
    };
};

/**
 * StageApi - object-oriented interface
 * @export
 * @class StageApi
 * @extends {BaseAPI}
 */
export class StageApi extends BaseAPI {
    /**
     * Return an array of stages by given request id
     * @summary Return an array of stages by given request id
     * @param {string} requestId Id of request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StageApi
     */
    public listStagesByRequest(requestId: string, options?: any) {
        return StageApiFp(this.configuration).listStagesByRequest(requestId, options)(this.axios, this.basePath);
    }

    /**
     * Return an approval stage by given id
     * @summary Return an approval stage by given id
     * @param {string} id Query by id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StageApi
     */
    public showStage(id: string, options?: any) {
        return StageApiFp(this.configuration).showStage(id, options)(this.axios, this.basePath);
    }

}

/**
 * TemplateApi - axios parameter creator
 * @export
 */
export const TemplateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return all templates
         * @summary Return all templates
         * @param {number} [limit] How many items to return at one time (max 1000)
         * @param {number} [offset] Starting Offset
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTemplates(limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            const localVarPath = `/templates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a template by given id
         * @summary Return a template by given id
         * @param {string} id Query by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showTemplate(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showTemplate.');
            }
            const localVarPath = `/templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplateApi - functional programming interface
 * @export
 */
export const TemplateApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Return all templates
         * @summary Return all templates
         * @param {number} [limit] How many items to return at one time (max 1000)
         * @param {number} [offset] Starting Offset
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTemplates(limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplateOutCollection> {
            const localVarAxiosArgs = TemplateApiAxiosParamCreator(configuration).listTemplates(limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Return a template by given id
         * @summary Return a template by given id
         * @param {string} id Query by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showTemplate(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplateOut> {
            const localVarAxiosArgs = TemplateApiAxiosParamCreator(configuration).showTemplate(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TemplateApi - factory interface
 * @export
 */
export const TemplateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Return all templates
         * @summary Return all templates
         * @param {number} [limit] How many items to return at one time (max 1000)
         * @param {number} [offset] Starting Offset
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTemplates(limit?: number, offset?: number, filter?: any, options?: any) {
            return TemplateApiFp(configuration).listTemplates(limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Return a template by given id
         * @summary Return a template by given id
         * @param {string} id Query by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showTemplate(id: string, options?: any) {
            return TemplateApiFp(configuration).showTemplate(id, options)(axios, basePath);
        },
    };
};

/**
 * TemplateApi - object-oriented interface
 * @export
 * @class TemplateApi
 * @extends {BaseAPI}
 */
export class TemplateApi extends BaseAPI {
    /**
     * Return all templates
     * @summary Return all templates
     * @param {number} [limit] How many items to return at one time (max 1000)
     * @param {number} [offset] Starting Offset
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    public listTemplates(limit?: number, offset?: number, filter?: any, options?: any) {
        return TemplateApiFp(this.configuration).listTemplates(limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Return a template by given id
     * @summary Return a template by given id
     * @param {string} id Query by id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    public showTemplate(id: string, options?: any) {
        return TemplateApiFp(this.configuration).showTemplate(id, options)(this.axios, this.basePath);
    }

}

/**
 * WorkflowApi - axios parameter creator
 * @export
 */
export const WorkflowApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a workflow by given template id
         * @summary Add a workflow by given template id
         * @param {string} templateId Id of template
         * @param {WorkflowIn} workflowIn Parameters need to create workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWorkflowToTemplate(templateId: string, workflowIn: WorkflowIn, options: any = {}): RequestArgs {
            // verify required parameter 'templateId' is not null or undefined
            if (templateId === null || templateId === undefined) {
                throw new RequiredError('templateId','Required parameter templateId was null or undefined when calling addWorkflowToTemplate.');
            }
            // verify required parameter 'workflowIn' is not null or undefined
            if (workflowIn === null || workflowIn === undefined) {
                throw new RequiredError('workflowIn','Required parameter workflowIn was null or undefined when calling addWorkflowToTemplate.');
            }
            const localVarPath = `/templates/{template_id}/workflows`
                .replace(`{${"template_id"}}`, encodeURIComponent(String(templateId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WorkflowIn" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(workflowIn || {}) : (workflowIn || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete approval workflow by given id
         * @summary Delete approval workflow by given id
         * @param {string} id Query by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyWorkflow(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling destroyWorkflow.');
            }
            const localVarPath = `/workflows/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return all approval workflows
         * @summary Return all approval workflows
         * @param {number} [limit] How many items to return at one time (max 1000)
         * @param {number} [offset] Starting Offset
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflows(limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            const localVarPath = `/workflows`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return an array of workflows by given template id
         * @summary Return an array of workflows by given template id
         * @param {string} templateId Id of template
         * @param {number} [limit] How many items to return at one time (max 1000)
         * @param {number} [offset] Starting Offset
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowsByTemplate(templateId: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'templateId' is not null or undefined
            if (templateId === null || templateId === undefined) {
                throw new RequiredError('templateId','Required parameter templateId was null or undefined when calling listWorkflowsByTemplate.');
            }
            const localVarPath = `/templates/{template_id}/workflows`
                .replace(`{${"template_id"}}`, encodeURIComponent(String(templateId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return an approval workflow by given id
         * @summary Return an approval workflow by given id
         * @param {string} id Query by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showWorkflow(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showWorkflow.');
            }
            const localVarPath = `/workflows/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an approval workflow by given id
         * @summary Update an approval workflow by given id
         * @param {string} id Query by id
         * @param {WorkflowIn} workflowIn Parameters need to update approval workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflow(id: string, workflowIn: WorkflowIn, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateWorkflow.');
            }
            // verify required parameter 'workflowIn' is not null or undefined
            if (workflowIn === null || workflowIn === undefined) {
                throw new RequiredError('workflowIn','Required parameter workflowIn was null or undefined when calling updateWorkflow.');
            }
            const localVarPath = `/workflows/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WorkflowIn" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(workflowIn || {}) : (workflowIn || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowApi - functional programming interface
 * @export
 */
export const WorkflowApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Add a workflow by given template id
         * @summary Add a workflow by given template id
         * @param {string} templateId Id of template
         * @param {WorkflowIn} workflowIn Parameters need to create workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWorkflowToTemplate(templateId: string, workflowIn: WorkflowIn, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowOut> {
            const localVarAxiosArgs = WorkflowApiAxiosParamCreator(configuration).addWorkflowToTemplate(templateId, workflowIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete approval workflow by given id
         * @summary Delete approval workflow by given id
         * @param {string} id Query by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyWorkflow(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = WorkflowApiAxiosParamCreator(configuration).destroyWorkflow(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Return all approval workflows
         * @summary Return all approval workflows
         * @param {number} [limit] How many items to return at one time (max 1000)
         * @param {number} [offset] Starting Offset
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflows(limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowOutCollection> {
            const localVarAxiosArgs = WorkflowApiAxiosParamCreator(configuration).listWorkflows(limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Return an array of workflows by given template id
         * @summary Return an array of workflows by given template id
         * @param {string} templateId Id of template
         * @param {number} [limit] How many items to return at one time (max 1000)
         * @param {number} [offset] Starting Offset
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowsByTemplate(templateId: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowOutCollection> {
            const localVarAxiosArgs = WorkflowApiAxiosParamCreator(configuration).listWorkflowsByTemplate(templateId, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Return an approval workflow by given id
         * @summary Return an approval workflow by given id
         * @param {string} id Query by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showWorkflow(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowOut> {
            const localVarAxiosArgs = WorkflowApiAxiosParamCreator(configuration).showWorkflow(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update an approval workflow by given id
         * @summary Update an approval workflow by given id
         * @param {string} id Query by id
         * @param {WorkflowIn} workflowIn Parameters need to update approval workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflow(id: string, workflowIn: WorkflowIn, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowOut> {
            const localVarAxiosArgs = WorkflowApiAxiosParamCreator(configuration).updateWorkflow(id, workflowIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WorkflowApi - factory interface
 * @export
 */
export const WorkflowApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Add a workflow by given template id
         * @summary Add a workflow by given template id
         * @param {string} templateId Id of template
         * @param {WorkflowIn} workflowIn Parameters need to create workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWorkflowToTemplate(templateId: string, workflowIn: WorkflowIn, options?: any) {
            return WorkflowApiFp(configuration).addWorkflowToTemplate(templateId, workflowIn, options)(axios, basePath);
        },
        /**
         * Delete approval workflow by given id
         * @summary Delete approval workflow by given id
         * @param {string} id Query by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyWorkflow(id: string, options?: any) {
            return WorkflowApiFp(configuration).destroyWorkflow(id, options)(axios, basePath);
        },
        /**
         * Return all approval workflows
         * @summary Return all approval workflows
         * @param {number} [limit] How many items to return at one time (max 1000)
         * @param {number} [offset] Starting Offset
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflows(limit?: number, offset?: number, filter?: any, options?: any) {
            return WorkflowApiFp(configuration).listWorkflows(limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Return an array of workflows by given template id
         * @summary Return an array of workflows by given template id
         * @param {string} templateId Id of template
         * @param {number} [limit] How many items to return at one time (max 1000)
         * @param {number} [offset] Starting Offset
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowsByTemplate(templateId: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return WorkflowApiFp(configuration).listWorkflowsByTemplate(templateId, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Return an approval workflow by given id
         * @summary Return an approval workflow by given id
         * @param {string} id Query by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showWorkflow(id: string, options?: any) {
            return WorkflowApiFp(configuration).showWorkflow(id, options)(axios, basePath);
        },
        /**
         * Update an approval workflow by given id
         * @summary Update an approval workflow by given id
         * @param {string} id Query by id
         * @param {WorkflowIn} workflowIn Parameters need to update approval workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflow(id: string, workflowIn: WorkflowIn, options?: any) {
            return WorkflowApiFp(configuration).updateWorkflow(id, workflowIn, options)(axios, basePath);
        },
    };
};

/**
 * WorkflowApi - object-oriented interface
 * @export
 * @class WorkflowApi
 * @extends {BaseAPI}
 */
export class WorkflowApi extends BaseAPI {
    /**
     * Add a workflow by given template id
     * @summary Add a workflow by given template id
     * @param {string} templateId Id of template
     * @param {WorkflowIn} workflowIn Parameters need to create workflow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public addWorkflowToTemplate(templateId: string, workflowIn: WorkflowIn, options?: any) {
        return WorkflowApiFp(this.configuration).addWorkflowToTemplate(templateId, workflowIn, options)(this.axios, this.basePath);
    }

    /**
     * Delete approval workflow by given id
     * @summary Delete approval workflow by given id
     * @param {string} id Query by id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public destroyWorkflow(id: string, options?: any) {
        return WorkflowApiFp(this.configuration).destroyWorkflow(id, options)(this.axios, this.basePath);
    }

    /**
     * Return all approval workflows
     * @summary Return all approval workflows
     * @param {number} [limit] How many items to return at one time (max 1000)
     * @param {number} [offset] Starting Offset
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public listWorkflows(limit?: number, offset?: number, filter?: any, options?: any) {
        return WorkflowApiFp(this.configuration).listWorkflows(limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Return an array of workflows by given template id
     * @summary Return an array of workflows by given template id
     * @param {string} templateId Id of template
     * @param {number} [limit] How many items to return at one time (max 1000)
     * @param {number} [offset] Starting Offset
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public listWorkflowsByTemplate(templateId: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return WorkflowApiFp(this.configuration).listWorkflowsByTemplate(templateId, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Return an approval workflow by given id
     * @summary Return an approval workflow by given id
     * @param {string} id Query by id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public showWorkflow(id: string, options?: any) {
        return WorkflowApiFp(this.configuration).showWorkflow(id, options)(this.axios, this.basePath);
    }

    /**
     * Update an approval workflow by given id
     * @summary Update an approval workflow by given id
     * @param {string} id Query by id
     * @param {WorkflowIn} workflowIn Parameters need to update approval workflow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public updateWorkflow(id: string, workflowIn: WorkflowIn, options?: any) {
        return WorkflowApiFp(this.configuration).updateWorkflow(id, workflowIn, options)(this.axios, this.basePath);
    }

}

